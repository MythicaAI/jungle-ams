import React, { memo, useCallback, useEffect, useRef, useState } from 'react';
import { useReactFlow } from '@xyflow/react';
import MonacoEditor from '@monaco-editor/react';

import useAutomation from '../../hooks/useAutomation';


import {
  AutomationScript,
  AutomationSpec,
  AutomationTask,
  ExecutionData,
  dictionary
} from '../../types/Automation';
import { NodeState } from '../../types/AwfulFlow';
import { JSONSchema } from '../../types/JSONSchema';
import { Button, IconButton, Input, Stack, Typography } from '@mui/joy';
import { NodeDeleteButton } from './ux/NodeDeleteButton';
import { NodeHeader } from './ux/NodeHeader';
import LockOpenIcon from '@mui/icons-material/LockOpen';
import LockOutlineIcon from '@mui/icons-material/LockOutline';
import AutomationNode from './AutomationNode';

/*
 * We store variants of execution data for an automation. 
 * AutomationExecutionData stores data generated by 
 * the automation itself. For prebuilt automations
 * provided by the back end, these are the only execution data
 * available. 
 * 
 * InterfaceExecutionData stores parameterSpecs (via JSON schmema)
 * for the automation and help this node display the correct
 * UI for the automation (inputHandles, outputHandles, and form elements). 
 * For built in automations, the parameterSpec is defined in the automation
 * itself (see AutomationProvider) 
 */
type InterfaceExecutionData = ExecutionData & {
  output: {
    automations?: {
      [key: string]: { input?: dictionary[]; output?: JSONSchema };
    };
    [key: string]: unknown;
  };
};

export interface ScriptNodeProps {
  id: string;
  selected?: boolean;
  data: {
    automation: string;
    inputData: dictionary;
    script: AutomationScript;
    executionData: ExecutionData;
  };
}

/**
 * Template for a client side scripted automation. The 
 * automation is written in Python and uses the Pydantic
 * library for data validation. The automation is expected
 * to accept an Object of Class RequestModel and return a 
 * ResponseModel object. The signature of runAutomation and 
 * the RequestModel and ResponseModel classes should not be
 * changed. (though their internals can be modified as needed)
 */
const template = `
from pydantic import BaseModel, Field
from ripple.automation.publishers import ResultPublisher
from ripple.models.params import ParameterSet, FileParameter
from ripple.models.streaming import ProcessStreamItem, OutputFiles 
from ripple.automation.automations import ( 
    automation_request,
    automation_response,
    automation
)
@automation_request()
class RequestModel(ParameterSet):
  pass

@automation_response()
class ResponseModel(OutputFiles):
  files: dict[str, list[str]] = Field(default={"Files": []})

@automation()
def runAutomation(request: RequestModel, responder: ResultPublisher) -> ResponseModel:
  pass
`;


const ScriptNode: React.FC<ScriptNodeProps> = (node) => {
  const scriptPath = import.meta.env.VITE_AWFUL_SCRIPT_PATH;
  const scriptInterfacePath = import.meta.env.VITE_AWFUL_SCRIPT_INTERFACE_PATH;

  const { deleteElements } = useReactFlow();

  const {
    initAutomation,
    runAutomation,
    parseAutomation,
    allAutomations,
    newAutomation,
    saveAutomation,
  } = useAutomation(); //provides automation related services.
  const automationTask = allAutomations[node.data.automation];


  const makeVirtualTask = useCallback((
    spec: AutomationSpec = {input: [] as dictionary[], output: {} as JSONSchema, hidden: false}
  ) => {
    return {
      worker: automationTask?.worker,
      path: automationTask?.path,
      uri: automationTask?.uri,
      spec: spec,
    } as AutomationTask;
  }, [automationTask]);


  const [virtualTask, setVirtualTask] = useState<AutomationTask>(
    makeVirtualTask()
  );

  const [myExecutionData, setMyExecutionData] = useState<ExecutionData>(
    node.data.executionData || initAutomation(automationTask)
  );
  const [myInterfaceData, setMyInterfaceData] = useState<ExecutionData>(
    initAutomation(automationTask)
  );

  const [flowExecutionMessage, setFlowExecutionMessage] = useState<string>('');



  const [saveName, setSaveName] = useState<string>(node.data.script?.name);
  const [scriptContent, setScriptContent] = useState<string>(
    node.data.script?.script || template
  ); // State to store Monaco editor content

  // Initialize editor visibility based on whether it's a new script or saved file
  const [isEditorVisible, setIsEditorVisible] = useState<boolean>(
    (!node.data.script?.script || node.data.script.script === template)
  );

  const timeout = 2000;
  const typingTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);

  const handleSaveAutomation = useCallback(() => {
    if (!node.data.script?.name || node.data.script.name === '') {
      console.error('Name is required');
      return;
    }

    saveAutomation(node.data.script, (saved: AutomationScript) => {
      node.data.script = saved;
    });
  }, [saveAutomation, node.data]);



  // Handler for Monaco editor changes
  const handleEditorChange = useCallback(
    (value: string | undefined) => {
      setScriptContent(value || '');
    },
    [setScriptContent]
  );


  const processOutputMessage = useCallback((execData: ExecutionData) => {
    const automationOutput = execData.output;
    if (automationOutput && automationOutput.message) {
      setFlowExecutionMessage(automationOutput.message as string);
    } else if (automationOutput && automationOutput.error) {
      setFlowExecutionMessage(automationOutput.error as string);
    } else {
      setFlowExecutionMessage('');
    }
  }, []);

  const processInterfaceOutput = useCallback(async () => {
    const generateAutomationInterface = () => {
      const automationOutput = (myInterfaceData as InterfaceExecutionData)
        .output;
      if (automationOutput.automations) {
        const thisAutomation = automationOutput.automations?.[scriptPath] || {};
        const mytasks = parseAutomation(node.id, {
          internal: {
            hidden: false,
            input: thisAutomation.input as dictionary[],
            output: thisAutomation.output as JSONSchema,
          },
        });
        setVirtualTask(makeVirtualTask(mytasks[0].spec));
        myInterfaceData.state = NodeState.Clean;
      }
    };

    try {
      generateAutomationInterface();
      processOutputMessage(myInterfaceData);
    } catch (error) {
      console.error('Error parsing worker output', error);
      myInterfaceData.state = NodeState.Error;
    }
  }, [
    myInterfaceData,
    scriptPath,
    parseAutomation,
    node.id,
    processOutputMessage,
  ]);

  useEffect(() => {
    if (typingTimeout.current) {
      clearTimeout(typingTimeout.current);
    }
    typingTimeout.current = setTimeout(() => {
      runAutomation(
        automationTask?.worker,
        node.id,
        scriptInterfacePath,
        { script: scriptContent },
        setMyInterfaceData
      );
    }, timeout); // Adjust delay as needed
  }, [scriptContent, runAutomation, automationTask?.worker, node.id]);


  // Process automation output when interface data changes
  useEffect(() => {
    const executed = myInterfaceData.state === NodeState.Executed;
    if (executed) processInterfaceOutput();
  }, [myInterfaceData, processInterfaceOutput]);

  // Update node save data when it changes
  useEffect(() => {
    if (node.data.script) {
      node.data.script.script = scriptContent;
      node.data.script.name = saveName;
    } else {
      node.data.script = newAutomation(
        automationTask?.worker,
        saveName,
        scriptContent
      );
    }
  }, [
    node.data,
    saveName,
    scriptContent,
    automationTask?.worker,
    newAutomation,
  ]);


  const min = 300;

  const toggleEditorVisibility = () => {
    setIsEditorVisible(!isEditorVisible);
  };

  if (!myInterfaceData) {
    return (
      <div className="mythica-node script">
        <NodeHeader />
        <Typography level="h3">Loading...</Typography>
      </div>
    );
  }

  return (
    <div
      style={{
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        position: 'relative', // Added relative positioning
      }}
    >

      <div
        className={`mythica-node script ${myExecutionData.state
          } ${node.selected && 'selected'}`}
        style={{
          minHeight: min,
          position: 'relative',
        }}
      >



        <NodeDeleteButton
          onDelete={() => {
            deleteElements({ nodes: [node] });
          }}
        />
        <NodeHeader />


        <div>
          <Typography level="h3" sx={{ display: 'flex', alignItems: 'center' }}>
            {saveName}
            <IconButton
              size="sm"
              sx={{ ml: 1 }}
              onClick={toggleEditorVisibility}
            >
              {isEditorVisible ? <LockOpenIcon /> : <LockOutlineIcon />}
            </IconButton>
          </Typography>
          <Typography level="h4">{automationTask?.uri}</Typography>
          <p>State: {myExecutionData.state}</p>
        </div>


        <AutomationNode
          nochrome
          id={node.id}
          selected={node.selected}
          data={{
            automation: virtualTask as AutomationTask,
            inputData: {...node.data.inputData },
            executionData: myExecutionData,
          }}
          setExecutionData={setMyExecutionData}
          beforeRunAutomation={(submitData: dictionary) => ({
              request_data:submitData,
              script: scriptContent,
            })
          }
        />

        {isEditorVisible && (
          <div
            className="script-editor nodrag"
            style={{
              position: 'absolute',
              top: '0',
              bottom: '0',
              left: '100%',
              width: '640px',
              resize: 'both',
              overflow: 'hidden',
              minWidth: '640px',
              minHeight: '640px',
              border: '1px solid #2d2d2d',
              display: 'flex',
              flexDirection: 'column',
              backgroundColor: '#1e1e1e',
              zIndex: 10,
              boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)'
            }}
          >
            <div
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: '8px 12px',
                borderBottom: '1px solid #333',
                backgroundColor: '#252525'
              }}
            >
              <Typography level="body-sm">Script Editor</Typography>
              <IconButton
                size="sm"
                onClick={toggleEditorVisibility}
              >
                <LockOpenIcon />
              </IconButton>
            </div>

            <Stack direction="row" spacing={1} sx={{ p: 2 }}>
              <Input
                type="text"
                defaultValue={saveName}
                onChange={(e) => setSaveName(e.target.value)}
                sx={{ flex: 1 }}
                placeholder="Script name"
              />
              <Button
                onClick={handleSaveAutomation}
                sx={{ width: '120px' }}
              >
                Save
              </Button>
            </Stack>

            <div
              style={{
                flex: 1,
                display: 'flex',
                flexDirection: 'column',
                position: 'relative',
                borderTop: '1px solid #333',
                minHeight: 0, // Add this to allow container to shrink
                overflow: 'auto', // Make this scrollable if content is too large
              }}
            >
              <div style={{ flex: '1 1 auto', overflow: 'hidden' }}>
                <MonacoEditor
                  language="python"
                  theme="vs-dark"
                  defaultValue={scriptContent}
                  onChange={handleEditorChange}
                  options={{
                    minimap: { enabled: false },
                    automaticLayout: true,
                  }}
                />
              </div>
            </div>

            <div
              className="nowheel"
              style={{
                borderTop: '1px solid #333',
                backgroundColor: '#252525',
                display: 'flex',
                maxHeight: '200px',
                flexDirection: 'column',
                overflow: 'hidden' // Changed from auto to hidden
              }}
            >
              <div style={{
                padding: '8px 12px',
                display: 'flex',
                justifyContent: 'space-between',
                flexShrink: 0 // Prevent header from shrinking
              }}>
                <Typography level="body-sm">Execution Output</Typography>
                <Typography level="body-sm">{myExecutionData.state}</Typography>
              </div>
              <div style={{
                flex: '1',
                overflow: 'auto',
                padding: '0 12px 12px'
              }}>
                <pre
                  style={{
                    margin: 0,
                    width: '100%',
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                    fontSize: '12px',
                  }}
                >
                  {flowExecutionMessage}
                </pre>
              </div>
            </div>

            {/* Resize handle indicator at the bottom-right corner */}
            <div
              style={{
                position: 'absolute',
                right: 0,
                bottom: 0,
                width: '16px',
                height: '16px',
                cursor: 'nwse-resize',
                backgroundImage: 'linear-gradient(135deg, transparent 50%, #555 50%, #555 60%, transparent 60%), linear-gradient(45deg, transparent 50%, #555 50%, #555 60%, transparent 60%)',
                backgroundSize: '8px 8px',
                backgroundPosition: 'right bottom',
                backgroundRepeat: 'no-repeat',
                pointerEvents: 'none'
              }}
            />
          </div>
        )}


        <div style={{ height: '24px' }} />
      </div>
    </div>
  );
};

export default memo(ScriptNode);
