import React, { memo, useCallback, useEffect, useRef, useState } from 'react';
import { useReactFlow, useUpdateNodeInternals } from '@xyflow/react';
import MonacoEditor from '@monaco-editor/react';

import useAutomation from '../../hooks/useAutomation';
import useAwfulFlow from '../../hooks/useAwfulFlow';
import useMythicaApi from '../../hooks/useMythicaApi';

import AutomationInputs from './automationParms/AutomationInputs';
import AutomationOutputs from './automationParms/AutomationOutputs';

import {
  AutomationScript,
  ExecutionData,
  FileParamType,
  dictionary
} from '../../types/Automation';
import { NodeState } from '../../types/AwfulFlow';
import { JSONSchema } from '../../types/JSONSchema';
import FileInputHandle from '../handles/FileInputHandle';
import FileOutputHandle from '../handles/FileOutputHandle';
import { Button, IconButton, Input, Stack, Typography } from '@mui/joy';
import { NodeDeleteButton } from './ux/NodeDeleteButton';
import { NodeHeader } from './ux/NodeHeader';
import LockOpenIcon from '@mui/icons-material/LockOpen';
import LockOutlineIcon from '@mui/icons-material/LockOutline';

/*
 * We store variants of execution data for an automation. 
 * AutomationExecutionData stores data generated by 
 * the automation itself. For prebuilt automations
 * provided by the back end, these are the only execution data
 * available. 
 * 
 * InterfaceExecutionData stores parameterSpecs (via JSON schmema)
 * for the automation and help this node display the correct
 * UI for the automation (inputHandles, outputHandles, and form elements). 
 * For built in automations, the parameterSpec is defined in the automation
 * itself (see AutomationProvider) 
 */
export type AutomationExecutionData = ExecutionData & {
  output: {
    files?: {
      [key: string]: string[];
    };
    [key: string]: unknown;
  };
};
type InterfaceExecutionData = ExecutionData & {
  output: {
    automations?: {
      [key: string]: { input?: dictionary[]; output?: JSONSchema };
    };
    [key: string]: unknown;
  };
};

export interface AutomationNodeProps {
  id: string;
  selected?: boolean;
  data: {
    automation: string;
    inputData: dictionary;
    script: AutomationScript;
    executionData: ExecutionData;
  };
}

/**
 * Template for a client side scripted automation. The 
 * automation is written in Python and uses the Pydantic
 * library for data validation. The automation is expected
 * to accept an Object of Class RequestModel and return a 
 * ResponseModel object. The signature of runAutomation and 
 * the RequestModel and ResponseModel classes should not be
 * changed. (though their internals can be modified as needed)
 */
const template = `
from pydantic import BaseModel, Field
from ripple.automation.publishers import ResultPublisher
from ripple.models.params import ParameterSet, FileParameter
from ripple.models.streaming import ProcessStreamItem, OutputFiles 
from ripple.automation.automations import ( 
    automation_request,
    automation_response,
    automation
)
@automation_request()
class RequestModel(ParameterSet):
  pass

@automation_response()
class ResponseModel(OutputFiles):
  files: dict[str, list[str]] = Field(default={"Files": []})

@automation()
def runAutomation(request: RequestModel, responder: ResultPublisher) -> ResponseModel:
  pass
`;

const AutomationNode: React.FC<AutomationNodeProps> = (node) => {
  const scriptPath = import.meta.env.VITE_AWFUL_SCRIPT_PATH;
  const scriptInterfacePath = import.meta.env.VITE_AWFUL_SCRIPT_INTERFACE_PATH;

  const updateNodeInternals = useUpdateNodeInternals();
  const { deleteElements } = useReactFlow();

  const {
    initAutomation,
    runAutomation,
    parseAutomation,
    allAutomations,
    newAutomation,
    saveAutomation,
  } = useAutomation(); //provides automation related services.
  const automationTask = allAutomations[node.data.automation];
  const isScriptNode = automationTask?.path === scriptPath;

  const [myExecutionData, setMyExecutionData] = useState<ExecutionData>(
    node.data.executionData || initAutomation(automationTask)
  );
  const [myInterfaceData, setMyInterfaceData] = useState<ExecutionData>(
    initAutomation(automationTask)
  );
  const { getFile } = useMythicaApi();

  const { NodeResizer, getFlowData, setFlowData } = useAwfulFlow(); //node data mapped to connections
  const myFlowData = getFlowData(node.id);
  const [flowExecutionMessage, setFlowExecutionMessage] = useState<string>('');

  //Input and Outputs Interface specs in JSONSpec (script Nodes are set later)
  const [inputSpec, setInputSpec] = useState(
    !isScriptNode
      ? automationTask?.spec.input
      : []
  );
  const [outputSpec, setOutputSpec] = useState(
    !isScriptNode
      ? automationTask?.spec.output
      : { title: 'Empty', type: 'string' }
  );

  //Input File parameters detected by AutomationInputs and type (array or scalar)
  const [inputFileKeys, setInputFileKeys] = useState<
    Record<string, FileParamType>
  >({});
  //Output File parameters detected by AutomationOutputs
  const [outputFileKeys, setOutputFileKeys] = useState<Set<string>>(new Set()); // Store file_id parameters

  //Input (form) data from AutomationInputs component
  const [inputData, setInputData] = useState<dictionary>(node.data.inputData);
  //FileParameter  Inputs are handled separately based on flowData
  const [fileInputData, setFileInputData] = useState<dictionary>({});

  const [saveName, setSaveName] = useState<string>(node.data.script?.name);
  const [scriptContent, setScriptContent] = useState<string>(
    node.data.script?.script || template
  ); // State to store Monaco editor content

  // Initialize editor visibility based on whether it's a new script or saved file
  const [isEditorVisible, setIsEditorVisible] = useState<boolean>(
    isScriptNode && (!node.data.script?.script || node.data.script.script === template)
  );

  const timeout = 2000;
  const typingTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);

  const handleSaveAutomation = useCallback(() => {
    if (!node.data.script?.name || node.data.script.name === '') {
      console.error('Name is required');
      return;
    }

    saveAutomation(node.data.script, (saved: AutomationScript) => {
      node.data.script = saved;
    });
  }, [saveAutomation, node.data]);

  // Handler for FileParameter inputs detected by AutomationInputs
  const handleFileParameterDetected = useCallback(
    (inputFileKeys: Record<string, FileParamType>) => {
      setInputFileKeys(inputFileKeys);
      updateNodeInternals(node.id);
    },
    [updateNodeInternals, node.id]
  );

  // Handler for FileOutput keys detected by AutomationOutputs
  const handleFileOutputDetected = useCallback(
    (fileOutputKeys: Set<string>) => {
      setOutputFileKeys(fileOutputKeys);
      updateNodeInternals(node.id);
    },
    [updateNodeInternals, node.id]
  );

  // Handler for running the automation
  const handleRunAutomation = () => {
    if (isScriptNode) {
      runAutomation(
        automationTask?.worker,
        node.id,
        automationTask?.path,
        {
          script: scriptContent,
          request_data: { ...inputData, ...fileInputData },
        },
        setMyExecutionData
      );
    } else {
      runAutomation(
        automationTask?.worker,
        node.id,
        automationTask?.path,
        { ...inputData, ...fileInputData },
        setMyExecutionData
      );
    }
  };

  // Handler for Monaco editor changes
  const handleEditorChange = useCallback(
    (value: string | undefined) => {
      setScriptContent(value || '');
    },
    [setScriptContent]
  );

  /**
   * Update fileInputs with the resolved file_id values
   * when the flowData changes.
   * This is necessary to ensure that the fileInputs
   *  are up-to-date with the latest file_id values.
   */
  const updateFileInputs = useCallback(() => {
    if (inputFileKeys) {
      Object.keys(inputFileKeys).forEach((paramKey) => {
        const fileParamType = inputFileKeys[paramKey];
        const files = myFlowData?.[paramKey] as
          | { file_id: string }[]
          | undefined;

        if (files && Array.isArray(files)) {
          if (fileParamType === FileParamType.Array) {
            // Map files to an array of { file_id: file_id } dictionaries
            const fileDictArray = files.map((file) => ({
              file_id: file.file_id,
            }));

            setFileInputData((prev) => ({
              ...prev,
              [paramKey]: fileDictArray, // Array of { file_id: file_id }
            }));
          } else {
            // Take the first file_id and create a single-entry array
            const firstFile = files[0];
            const fileDictArray = firstFile
              ? { file_id: firstFile.file_id }
              : {};

            setFileInputData((prev) => ({
              ...prev,
              [paramKey]: fileDictArray, // Single-entry array
            }));
          }
        }
      });
    }
  }, [inputFileKeys, myFlowData]);

  const processOutputMessage = useCallback((execData: ExecutionData) => {
    const automationOutput = execData.output;
    if (automationOutput && automationOutput.message) {
      setFlowExecutionMessage(automationOutput.message as string);
    } else if (automationOutput && automationOutput.error) {
      setFlowExecutionMessage(automationOutput.error as string);
    } else {
      setFlowExecutionMessage('');
    }
  }, []);

  const processInterfaceOutput = useCallback(async () => {
    const generateAutomationInterface = () => {
      const automationOutput = (myInterfaceData as InterfaceExecutionData)
        .output;
      if (automationOutput.automations) {
        const thisAutomation = automationOutput.automations?.[scriptPath] || {};
        const automationTask = parseAutomation(node.id, {
          internal: {
            hidden: false,
            input: thisAutomation.input as dictionary[],
            output: thisAutomation.output as JSONSchema,
          },
        });
        setInputSpec(automationTask[0]?.spec.input);
        setOutputSpec(automationTask[0]?.spec.output);
        myInterfaceData.state = NodeState.Clean;
      }
    };

    try {
      generateAutomationInterface();
      processOutputMessage(myInterfaceData);
    } catch (error) {
      console.error('Error parsing worker output', error);
      myInterfaceData.state = NodeState.Error;
    }
  }, [
    myInterfaceData,
    scriptPath,
    parseAutomation,
    node.id,
    processOutputMessage,
  ]);

  /**
   * We have to special case scriptInterfacePath execution
   * as we get back a JSONSchema object that we need to parse
   * and use to update inputSpec and outputSpec.
   * For normal executions we just update the flowData with the output.
   * and notify our connections of hte change.
   */
  const processAutomationOutput = useCallback(async () => {
    const fetchAndResolveFiles = async (fileIds: string[]) => {
      const resolvedFiles = [];
      for (const file_id of fileIds) {
        try {
          const file = await getFile(file_id); // Call your API to resolve file_id
          resolvedFiles.push(file);
        } catch (error) {
          console.error(`Failed to resolve file_id: ${file_id}`, error);
          resolvedFiles.push(null);
        }
      }
      return resolvedFiles;
    };

    const updateFlowData = () => {
      const automationOutput = (myExecutionData as AutomationExecutionData)
        .output;
      if (automationOutput.files) {
        const fileKeys = Object.keys(automationOutput.files);
        for (const fileKey of fileKeys) {
          const fileIds = automationOutput.files[fileKey];
          if (Array.isArray(fileIds)) {
            fetchAndResolveFiles(fileIds).then((resolvedFiles) => {
              setFlowData(
                node.id,
                fileKey,
                resolvedFiles.filter((file) => file !== null)
              ); // Update flowData with resolved files
              myExecutionData.state = NodeState.Done;
            });
          }
        }
      }
    };

    try {
      updateFlowData();
      processOutputMessage(myExecutionData);
    } catch (error) {
      console.error('Error parsing worker output', error);
      myExecutionData.state = NodeState.Error;
    }
  }, [myExecutionData, node.id, setFlowData, getFile, processOutputMessage]);

  useEffect(() => {
    if (isScriptNode) {
      if (typingTimeout.current) {
        clearTimeout(typingTimeout.current);
      }
      typingTimeout.current = setTimeout(() => {
        runAutomation(
          automationTask?.worker,
          node.id,
          scriptInterfacePath,
          { script: scriptContent },
          setMyInterfaceData
        );
      }, timeout); // Adjust delay as needed
    }
  }, [scriptContent, runAutomation, automationTask?.worker, node.id]);

  // Update fileInputs when flowData changes or when the fileparams change
  useEffect(() => {
    if (inputFileKeys) updateFileInputs();
    else setFileInputData({});

    updateNodeInternals(node.id);
  }, [
    inputFileKeys,
    myFlowData,
    node.id,
    setFileInputData,
    updateNodeInternals,
    updateFileInputs,
  ]);

  // Process automation output when execution data changes
  useEffect(() => {
    const executed = myExecutionData.state === NodeState.Executed;
    if (executed) processAutomationOutput();
  }, [myExecutionData, processAutomationOutput]);

  // Process automation output when interface data changes
  useEffect(() => {
    const executed = myInterfaceData.state === NodeState.Executed;
    if (executed) processInterfaceOutput();
  }, [myInterfaceData, processInterfaceOutput]);

  // Update node save data when it changes
  useEffect(() => {
    node.data.inputData = { ...inputData, ...fileInputData };
    if (isScriptNode) {
      if (node.data.script) {
        node.data.script.script = scriptContent;
        node.data.script.name = saveName;
      } else {
        node.data.script = newAutomation(
          automationTask?.worker,
          saveName,
          scriptContent
        );
      }
    }
    node.data.executionData = myExecutionData;
  }, [
    node.data,
    inputData,
    fileInputData,
    saveName,
    scriptContent,
    inputSpec,
    outputSpec,
    isScriptNode,
    myExecutionData,
    automationTask?.worker,
    newAutomation,
  ]);

  const inputPositions = Array.from(Object.keys(inputFileKeys)).map(
    (_, index) =>
      `${(index + 1) * (100 / (Object.keys(inputFileKeys).length + 1))}%`
  );
  const outputPositions = Array.from(outputFileKeys).map(
    (_, index, array) => `${(index + 1) * (100 / (array.length + 1))}%`
  );

  const min = 300;

  const toggleEditorVisibility = () => {
    setIsEditorVisible(!isEditorVisible);
  };

  return (
    <div
      style={{
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        position: 'relative', // Added relative positioning
      }}
    >

      <div
        className={`mythica-node ${isScriptNode && 'script'} ${
          myExecutionData.state
        } ${node.selected && 'selected'}`}
        style={{
          minHeight: min,
          position: 'relative',
        }}
      >
        


        <NodeDeleteButton
          onDelete={() => {
            deleteElements({ nodes: [node] });
          }}
        />
        <NodeHeader />


        {isScriptNode ?
          <div>
            <Typography level="h3" sx={{ display: 'flex', alignItems: 'center' }}>
              {saveName}
              <IconButton 
                size="sm" 
                sx={{ ml: 1 }}
                onClick={toggleEditorVisibility}
              >
                {isEditorVisible ? <LockOpenIcon /> : <LockOutlineIcon />}
              </IconButton>
            </Typography>
            <Typography level="h4">{automationTask?.uri}</Typography>
            <p>State: {myExecutionData.state}</p>
          </div>

          :
          <div>
            <Typography level="h3">{automationTask?.uri}</Typography>
            <p>State: {myExecutionData.state}</p>
          </div>
        }

        {/* Input Handles */}
        {Array.from(Object.keys(inputFileKeys)).map((paramKey, index) => (
          <FileInputHandle
            nodeId={node.id}
            key={paramKey}
            id={paramKey}
            left={inputPositions[index]}
            isConnectable
            style={{ background: '#007bff' }}
            label={
              paramKey +
              (inputFileKeys[paramKey] === FileParamType.Array ? '[ ]' : '')
            }
          />
        ))}
        <>
          <AutomationInputs
            inputSchema={inputSpec}
            onChange={setInputData}
            inputData={inputData}
            onFileParameterDetected={handleFileParameterDetected}
          />
          <AutomationOutputs
            outputSchema={outputSpec}
            outputData={myExecutionData.output}
            onFileOutputDetected={handleFileOutputDetected}
          />
          <div className="nowheel" style={{ margin: '12px 0' }}>
            <pre 
              style={{ 
                overflow: 'auto', 
                maxHeight: '200px',
                width: '100%',
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-word',
                padding: '8px',
                borderRadius: '4px',
                fontSize: '12px'
              }}
            >
              {!isEditorVisible && flowExecutionMessage}
            </pre>
          </div>
        </>

        {isScriptNode && (
          <>
            {isEditorVisible && (
              <div
                className="script-editor nodrag"
                style={{
                  position: 'absolute',
                  top: '0',
                  bottom: '0',
                  left: '100%',
                  width: '640px',
                  resize: 'both',
                  overflow: 'hidden',
                  minWidth: '640px',
                  minHeight: '640px',
                  border: '1px solid #2d2d2d',
                  display: 'flex',
                  flexDirection: 'column',
                  backgroundColor: '#1e1e1e',
                  zIndex: 10,
                  boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)'
                }}
              >
                <div 
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '8px 12px',
                    borderBottom: '1px solid #333',
                    backgroundColor: '#252525'
                  }}
                >
                  <Typography level="body-sm">Script Editor</Typography>
                  <IconButton 
                    size="sm" 
                    onClick={toggleEditorVisibility}
                  >
                    <LockOpenIcon />
                  </IconButton>
                </div>

                <Stack direction="row" spacing={1} sx={{ p: 2 }}>
                  <Input
                    type="text"
                    defaultValue={saveName}
                    onChange={(e) => setSaveName(e.target.value)}
                    sx={{ flex: 1 }}
                    placeholder="Script name"
                  />
                  <Button 
                    onClick={handleSaveAutomation}
                    sx={{ width: '120px' }}
                  >
                    Save
                  </Button>
                </Stack>
                
                <div 
                  style={{ 
                    flex: 1, 
                    display: 'flex', 
                    flexDirection: 'column',
                    position: 'relative',
                    borderTop: '1px solid #333',
                    minHeight: 0, // Add this to allow container to shrink
                    overflow: 'auto', // Make this scrollable if content is too large
                  }}
                >
                  <div style={{ flex: '1 1 auto', overflow: 'hidden' }}>
                    <MonacoEditor
                      language="python"
                      theme="vs-dark"
                      defaultValue={scriptContent}
                      onChange={handleEditorChange}
                      options={{
                        minimap: { enabled: false },
                        automaticLayout: true,
                      }}
                    />
                  </div>
                </div>
                
                <div 
                  className="nowheel"
                  style={{
                    borderTop: '1px solid #333',
                    backgroundColor: '#252525', 
                    display: 'flex',
                    maxHeight: '200px',
                    flexDirection: 'column',
                    overflow: 'hidden' // Changed from auto to hidden
                  }}
                >
                  <div style={{ 
                    padding: '8px 12px', 
                    display: 'flex', 
                    justifyContent: 'space-between',
                    flexShrink: 0 // Prevent header from shrinking
                  }}>
                    <Typography level="body-sm">Execution Output</Typography>
                    <Typography level="body-sm">{myExecutionData.state}</Typography>
                  </div>
                  <div style={{ 
                    flex: '1',
                    overflow: 'auto',
                    padding: '0 12px 12px'
                  }}>
                    <pre 
                      style={{ 
                        margin: 0,
                        width: '100%',
                        whiteSpace: 'pre-wrap',
                        wordBreak: 'break-word',
                        fontSize: '12px',
                      }}
                    >
                      {flowExecutionMessage}
                    </pre>
                  </div>
                </div>
                
                {/* Resize handle indicator at the bottom-right corner */}
                <div 
                  style={{
                    position: 'absolute',
                    right: 0,
                    bottom: 0,
                    width: '16px',
                    height: '16px',
                    cursor: 'nwse-resize',
                    backgroundImage: 'linear-gradient(135deg, transparent 50%, #555 50%, #555 60%, transparent 60%), linear-gradient(45deg, transparent 50%, #555 50%, #555 60%, transparent 60%)',
                    backgroundSize: '8px 8px',
                    backgroundPosition: 'right bottom',
                    backgroundRepeat: 'no-repeat',
                    pointerEvents: 'none'
                  }}
                />
              </div>
            )}
          </>
        )}

        {/* Output Handles */}
        {Array.from(outputFileKeys).map((outputKey, index) => (
          <FileOutputHandle
            nodeId={node.id}
            key={outputKey}
            id={outputKey}
            left={outputPositions[index]}
            isConnectable
            style={{ background: '#555555' }}
            label={outputKey + '[ ]'}
          />
        ))}

        <Button
          onClick={handleRunAutomation}
          disabled={
            myExecutionData.state! in [NodeState.Clean, NodeState.Error]
          }
        >
          Run Automation
        </Button>
        <div style={{ height: '24px' }} />
      </div>
    </div>
  );
};

export default memo(AutomationNode);
