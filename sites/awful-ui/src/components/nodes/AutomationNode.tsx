import React, { Dispatch, memo, SetStateAction, useCallback, useEffect, useState } from 'react';
import { useReactFlow, useUpdateNodeInternals } from '@xyflow/react';

import useAutomation from '../../hooks/useAutomation';
import useAwfulFlow from '../../hooks/useAwfulFlow';
import useMythicaApi from '../../hooks/useMythicaApi';

import AutomationInputs from './automationParms/AutomationInputs';
import AutomationOutputs from './automationParms/AutomationOutputs';

import {
  ExecutionData,
  FileParamType,
  AutomationTask,
  dictionary
} from '../../types/Automation';
import { NodeState } from '../../types/AwfulFlow';
import FileInputHandle from '../handles/FileInputHandle';
import FileOutputHandle from '../handles/FileOutputHandle';
import { Button, Typography } from '@mui/joy';
import { NodeDeleteButton } from './ux/NodeDeleteButton';
import { NodeHeader } from './ux/NodeHeader';

interface NodeContainerProps {
  children: React.ReactNode;
  state: string;
  selected?: boolean;
  minHeight: number;
}

// Container component that wraps content with the outer divs
const NodeContainer: React.FC<NodeContainerProps> = ({ children, state, selected, minHeight }) => {
  return (
    <div
      style={{
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        position: 'relative',
      }}
    >
      <div
        className={`
          ${state} 
          mythica-node 
          ${selected ? 'selected' : ''}
        `}
        style={{
          minHeight: minHeight,
          position: 'relative',
        }}
      >
        {children}
      </div>
    </div>
  );
};

/*
 * AutomationExecutionData stores data generated by 
 * the automation. 
 */
export type AutomationExecutionData = ExecutionData & {
  output: {
    files?: {
      [key: string]: string[];
    };
    [key: string]: unknown;
  };
};

export interface AutomationNodeProps {
  id: string;
  selected?: boolean;
  data: {
    automation: string | AutomationTask;
    inputData: dictionary;
    executionData: ExecutionData;
  };
  nochrome?: boolean;
  beforeRunAutomation?: (submitData: dictionary) => dictionary;
  setExecutionData?: Dispatch<SetStateAction<ExecutionData>>;
}


const AutomationNode: React.FC<AutomationNodeProps> = (node) => {

  const updateNodeInternals = useUpdateNodeInternals();
  const { deleteElements } = useReactFlow();

  const {
    initAutomation,
    runAutomation,
    allAutomations,
    newAutomation,
  } = useAutomation(); //provides automation related services.

  const automationTask =
    typeof(node.data.automation) === "string" 
    ? allAutomations[node.data.automation] 
    : node.data.automation;

  const [localExecutionData, setLocalExecutionData] = useState<ExecutionData>(
    node.data.executionData || initAutomation(automationTask)
  );

  const setMyExecutionData = 
      node.setExecutionData
      ? node.setExecutionData
      : setLocalExecutionData;

  const myExecutionData = node.setExecutionData ?
    node.data.executionData : localExecutionData;

  const { getFile } = useMythicaApi();

  const { getFlowData, setFlowData } = useAwfulFlow(); //node data mapped to connections
  const myFlowData = getFlowData(node.id);
  const [flowExecutionMessage, setFlowExecutionMessage] = useState<string>('');


  //Input File parameters detected by AutomationInputs and type (array or scalar)
  const [inputFileKeys, setInputFileKeys] = useState<
    Record<string, FileParamType>
  >({});

  //Output File parameters detected by AutomationOutputs
  const [outputFileKeys, setOutputFileKeys] = useState<Set<string>>(new Set()); // Store file_id parameters

  //Input (form) data from AutomationInputs component
  const [inputData, setInputData] = useState<dictionary>(node.data.inputData || {});
  //FileParameter  Inputs are handled separately based on flowData
  const [fileInputData, setFileInputData] = useState<dictionary>({});


  // Handler for FileParameter inputs detected by AutomationInputs
  const handleFileParameterDetected = useCallback(
    (inputFileKeys: Record<string, FileParamType>) => {
      setInputFileKeys(inputFileKeys);
      updateNodeInternals(node.id);
    },
    [updateNodeInternals, node.id]
  );

  // Handler for FileOutput keys detected by AutomationOutputs
  const handleFileOutputDetected = useCallback(
    (fileOutputKeys: Set<string>) => {
      setOutputFileKeys(fileOutputKeys);
      updateNodeInternals(node.id);
    },
    [updateNodeInternals, node.id]
  );

  // Handler for running the automation
  const handleRunAutomation = () => {
    const submitData = {
      ...inputData,
      ...fileInputData,
    }
    // If a beforeRunCallback is provided, use it to modify the input data
    const finalData = node.beforeRunAutomation
      ? node.beforeRunAutomation(submitData)
      : submitData;

    runAutomation(
      automationTask?.worker,
      node.id,
      automationTask?.path,
      finalData,
      setMyExecutionData
    );
  };


  /**
   * Update fileInputs with the resolved file_id values
   * when the flowData changes.
   * This is necessary to ensure that the fileInputs
   *  are up-to-date with the latest file_id values.
   */
  const updateFileInputs = useCallback(() => {
    if (inputFileKeys) {
      Object.keys(inputFileKeys).forEach((paramKey) => {
        const fileParamType = inputFileKeys[paramKey];
        const files = myFlowData?.[paramKey] as
          | { file_id: string }[]
          | undefined;

        if (files && Array.isArray(files)) {
          if (fileParamType === FileParamType.Array) {
            // Map files to an array of { file_id: file_id } dictionaries
            const fileDictArray = files.map((file) => ({
              file_id: file.file_id,
            }));

            setFileInputData((prev) => ({
              ...prev,
              [paramKey]: fileDictArray, // Array of { file_id: file_id }
            }));
          } else {
            // Take the first file_id and create a single-entry array
            const firstFile = files[0];
            const fileDictArray = firstFile
              ? { file_id: firstFile.file_id }
              : {};

            setFileInputData((prev) => ({
              ...prev,
              [paramKey]: fileDictArray, // Single-entry array
            }));
          }
        }
      });
    }
  }, [inputFileKeys, myFlowData]);

  const processOutputMessage = useCallback((execData: ExecutionData) => {
    const automationOutput = execData.output;
    if (automationOutput && automationOutput.message) {
      setFlowExecutionMessage(automationOutput.message as string);
    } else if (automationOutput && automationOutput.error) {
      setFlowExecutionMessage(automationOutput.error as string);
    } else {
      setFlowExecutionMessage('');
    }
  }, []);


  /**
   * We have to special case scriptInterfacePath execution
   * as we get back a JSONSchema object that we need to parse
   * and use to update inputSpec and outputSpec.
   * For normal executions we just update the flowData with the output.
   * and notify our connections of hte change.
   */
  const processAutomationOutput = useCallback(async () => {
    const fetchAndResolveFiles = async (fileIds: string[]) => {
      const resolvedFiles = [];
      for (const file_id of fileIds) {
        try {
          const file = await getFile(file_id); // Call your API to resolve file_id
          resolvedFiles.push(file);
        } catch (error) {
          console.error(`Failed to resolve file_id: ${file_id}`, error);
          resolvedFiles.push(null);
        }
      }
      return resolvedFiles;
    };

    const updateFlowData = () => {
      const automationOutput = (myExecutionData as AutomationExecutionData).output;
      if (automationOutput.files) {
        const fileKeys = Object.keys(automationOutput.files);
        for (const fileKey of fileKeys) {
          const fileIds = automationOutput.files[fileKey];
          if (Array.isArray(fileIds)) {
            fetchAndResolveFiles(fileIds).then((resolvedFiles) => {
              setFlowData(
                node.id,
                fileKey,
                resolvedFiles.filter((file) => file !== null)
              ); // Update flowData with resolved files
              setMyExecutionData((prev) => ({ ...prev, state: NodeState.Done }));
            });
          }
        }
      }
    };

    try {
      updateFlowData();
      processOutputMessage(myExecutionData);
    } catch (error) {
      console.error('Error parsing worker output', error);
      setMyExecutionData((prev) => ({ ...prev, state: NodeState.Error }));
    }
  }, [myExecutionData, node.id, setFlowData, getFile, processOutputMessage]);


  // Update fileInputs when flowData changes or when the fileparams change
  useEffect(() => {
    if (inputFileKeys) updateFileInputs();
    else setFileInputData({});

    updateNodeInternals(node.id);
  }, [
    inputFileKeys,
    myFlowData,
    node.id,
    setFileInputData,
    updateNodeInternals,
    updateFileInputs,
  ]);

  // Process automation output when execution data changes
  useEffect(() => {
    const executed = myExecutionData.state === NodeState.Executed;
    if (executed) processAutomationOutput();
  }, [myExecutionData, processAutomationOutput]);


  // Update node save data when it changes
  useEffect(() => {
    node.data.inputData = { ...inputData, ...fileInputData };
    node.data.executionData = localExecutionData;
  }, [
    node.data,
    inputData,
    fileInputData,
    localExecutionData,
    automationTask?.worker,
    newAutomation,
  ]);

  const inputPositions = Array.from(Object.keys(inputFileKeys)).map(
    (_, index) =>
      `${(index + 1) * (100 / (Object.keys(inputFileKeys).length + 1))}%`
  );
  const outputPositions = Array.from(outputFileKeys).map(
    (_, index, array) => `${(index + 1) * (100 / (array.length + 1))}%`
  );

  const min = 300;

  // Create the content that will be inside the node
  const nodeContent = (
    <>
      {!node.nochrome && (
        <>
          <NodeDeleteButton
            onDelete={() => {
              deleteElements({ nodes: [node] });
            }}
          />
          <NodeHeader />
          <div>
            <Typography level="h3">{automationTask?.uri}</Typography>
            <p>State: {myExecutionData.state}</p>
          </div>
        </>
      )}
      
      {/* Input Handles */}
      {Array.from(Object.keys(inputFileKeys)).map((paramKey, index) => (
        <FileInputHandle
          nodeId={node.id}
          key={paramKey}
          id={paramKey}
          left={inputPositions[index]}
          isConnectable
          style={{ background: '#007bff' }}
          label={
            paramKey +
            (inputFileKeys[paramKey] === FileParamType.Array ? '[ ]' : '')
          }
        />
      ))}
      <>
        <AutomationInputs
          inputSchema={automationTask?.spec.input}
          onChange={setInputData}
          inputData={inputData}
          onFileParameterDetected={handleFileParameterDetected}
        />
        <AutomationOutputs
          outputSchema={automationTask?.spec.output}
          outputData={myExecutionData.output}
          onFileOutputDetected={handleFileOutputDetected}
        />
        <div className="nowheel" style={{ margin: '12px 0' }}>
          <pre 
            style={{ 
              overflow: 'auto', 
              maxHeight: '200px',
              width: '100%',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
              padding: '8px',
              borderRadius: '4px',
              fontSize: '12px'
            }}
          >
            {flowExecutionMessage}
          </pre>
        </div>
      </>
      
      {/* Output Handles */}
      {Array.from(outputFileKeys).map((outputKey, index) => (
        <FileOutputHandle
          nodeId={node.id}
          key={outputKey}
          id={outputKey}
          left={outputPositions[index]}
          isConnectable
          style={{ background: '#555555' }}
          label={outputKey + '[ ]'}
        />
      ))}

      <Button
        onClick={handleRunAutomation}
        disabled={
          myExecutionData.state! in [NodeState.Clean, NodeState.Error]
        }
      >
        Run Automation
      </Button>
      <div style={{ height: '24px' }} />
    </>
  );
  
  // Conditionally wrap the content with NodeContainer or return it directly
  return node.nochrome ? (
    nodeContent
  ) : (
    <NodeContainer 
      state={myExecutionData.state}
      selected={node.selected}
      minHeight={min}
    >
      {nodeContent}
    </NodeContainer>
  );
};

export default memo(AutomationNode);
