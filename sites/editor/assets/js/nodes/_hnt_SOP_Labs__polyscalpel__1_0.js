
export default function (hou) {
    class _hnt_SOP_Labs__polyscalpel__1_0 extends hou.extend(hou._HoudiniBase).with(hou._SubgraphMixin) {
        static is_root = false;
        static id = 'SOP/Labs/Geometry/Mesh: Cut/Labs::polyscalpel::1.0';
        static category = '/SOP/Labs';
        static houdiniType = 'Labs::polyscalpel::1.0';
        static title = 'Labs PolyScalpel';
        static icon = '/editor/assets/imgs/nodes/_hnt_SOP_Labs__polyscalpel__1_0.svg';
        constructor() {
            super();
            this.flags['houdini_type'] = this.__proto__.constructor.houdiniType;
            
            const inputs = ['SOP', 'SOP'];
            const outputs = ['SOP'];

            for(var i=0;i<inputs.length;i++) this.addInput(''+i,inputs[i]);        
            for(var j=0;j<outputs.length;j++) this.addOutput(''+j,outputs[j]);
        }
        parmTemplatesInit() {
            let hou_parm_template_group = new hou.ParmTemplateGroup();
			this.parmTemplateGroup = hou_parm_template_group;
			let hou_parm_template = new hou.FolderParmTemplate({name: "fd_geometryinput", label: "Geometry Input", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "simple"});
			let hou_parm_template2 = new hou.MenuParmTemplate({name: "inputGeoType", label: "Source Geo Type", menu_items: ["0", "1"], menu_labels: ["Polylines", "Polygon Surfaces"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("Set the type of geometry you are trying to cut.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "cuttingGeoType", label: "Cutting Geo Type", menu_items: ["0", "1", "2"], menu_labels: ["Points", "Polylines", "Polygon Surfaces"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("Set the type of geometry you are trying to cut the input geometry with.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "useConnectivity", label: "Use Source Mesh Connectivity", default_value: true});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType == 2 }");
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("When enabled, cuts are assigned to a connected set of primitives by assigning it a Connectivity ID. However in some cases you may want to treat all disconnected meshes as a single mesh, in which case the Connectitivy ID is set to -1. This option when disabled, can provide a performance boost when dealing with many disconnected Source and Cutting Primitives. (Alternatively, you may use \"Bind Cuts to Nearest Source Primitive\" for this as well). However, disabling connectivity checks can cause issues when meshes overlap, and previously disconnected source geometry may be fused together at their cuts. Enabled by default.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "bindToNearestSourcePrim", label: "Bind Cuts to Nearest Source Primitive (Faster)", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ useConnectivity == 0 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 1 }");
			hou_parm_template2.setHelp("When enabled, cutting primitives check from their center which connected source primitives are closest and assigns only to those primitives. Other disconnected primitives are ignored for that cutting primitive. Disabled by default, which allows one cutting primitive to affect multiple disconnected meshes at once without allowing them to fuse. In case many disconnected Source and Cutting primitives are provided, this option can provide a performance boost.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "crossCutSurface", label: "Cross Cut for Planar Surfaces", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 2 }");
			hou_parm_template2.setHelp("When enabled, this option interpolates the intersection as an edge hull instead, based on the cutting surface normal direction. Useful when 2 coincident non-planar surfaces / primitives are used as source and cutting inputs. The Cross Cut Depth affects the depth of the edge hull.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "extractIntersectionPoints", label: "Cut with Intersection Points from Cutting Geo", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 0 } { inputGeoType != 0 }");
			hou_parm_template2.setHelp("When enabled, you can provide Polyline Source Geometry to both inputs. This will detect intersections between the polylines and inject points on the Source Geometry with these points. High snap distance may over-detect and confuse intersections with geometry points nearby.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "crossCutDepth", label: "Cross-Cut Depth", num_components: 1, default_value: [0.2], min: 0, max: 10, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 2 } { crossCutSurface == 0 }");
			hou_parm_template2.setHelp("When using \"Cross Cut for Planar Surfaces\", determines the distance of the Cross Cut perpendicular from the cutting surface edges.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm6"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "sourceGroup", label: "Source Geo Group", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a splitBySourceGeoGroup group", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setHelp("Specify a group selection of the Source Primitives that can be Cut using the Cutting Geo Input");
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_action": "import soputils\nkwargs['geometrytype'] = (hou.geometryType.Primitives,)\nkwargs['inputindex'] = 0\nsoputils.selectGroupParm(kwargs)\n", "script_action_help": "Select geometry from an available viewport.", "script_action_icon": "BUTTONS_reselect"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "cuttingGroup", label: "Cutting Geo Group", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a splitByCuttingGeoGroup group", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setHelp("Specify a group selection of the Cutting Primitives that are allowed to make cuts. Takes a primitive group when cutting with surfaces or polylines. Takes points groups when cutting with points, except if \"Cut with intersection points\" is enabled, in this case it also requires a primitive group.");
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_action": "import soputils\nkwargs[\'geometrytype\'] = (hou.geometryType.Primitives,)\nval = kwargs[\'node\'].parm(\"cuttingGeoType\").eval()\nif val == 0:\n    kwargs[\'geometrytype\'] = (hou.geometryType.Points,)\n    \nkwargs[\'inputindex\'] = 1\nsoputils.selectGroupParm(kwargs)", "script_action_help": "Select geometry from an available viewport.", "script_action_icon": "BUTTONS_reselect"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.SeparatorParmTemplate({name: "sepparm"});
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_geometryoutput", label: "Geometry Output", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "simple"});
			hou_parm_template2 = new hou.MenuParmTemplate({name: "surfaceOutput", label: "Surface Output", menu_items: ["0", "1"], menu_labels: ["Points On Edges", "Slice Surfaces"], default_value: 1, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType == 0 } { cuttingGeoType == 0 }");
			hou_parm_template2.setHelp("Determines the type of Output. To either inject New Points on edges, or to cut a surface with a spline. Is enabled when cutting surfaces with Poly Surfaces or Poly Curves.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "surfaceCuttingMethod", label: "Slicing Method", menu_items: ["0", "1"], menu_labels: ["Poly Split - [ Slower / Supports Snapping / Scale Sensitive ]", "Boolean Shatter - [ Faster / Avoid Coincident Inputs ]"], default_value: 1, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType != 1 } { cuttingGeoType != 2 }");
			hou_parm_template2.setHelp("Determines how Surfaces are cut with Surfaces, Boolean based Slicing or point injection in general is more efficient, but it cannot use snapping features. Polysplit mode does feature snapping support and can auto complete cuts that don't slice an entire surface. PolySplit mode can be limited by its slow processing speed on large pieces of geometry, and may require high precision mode be enabled on dense geometry. If you need to cut a dense mesh with a surface, boolean mode is prefered.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "surfaceCuttingMethod_Dummy", label: "Slicing Method", menu_items: ["0"], menu_labels: ["Poly Split - [ Slower / Supports Snapping ]"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ cuttingGeoType != 100 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType == 1 cuttingGeoType == 2 }");
			hou_parm_template2.setHelp("Normally determines how Surfaces are cut with Surfaces. Disabled when not in the Surface cuts Surface Mode.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "includeSharedEdges", label: "Include Shared Edges From Cutting Geometry", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ surfaceOutput == 0 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType != 1 } { cuttingGeoType != 2 } { surfaceCuttingMethod == 0 }");
			hou_parm_template2.setHelp("When using the \"Boolean\" Surface Cutting Method with overlapping surfaces, shared edges of the Cutting geometry planar with the Source Geometry may be stamped into the Source Geometry. When this setting is enabled these edges are included in the Cut Edge Group and Cusp Cut Edges operations. Be aware that when using the Boolean Shatter Method, overlapping Cutting Geometry can only correctly detect cuts like these when they are in exact overlap with a Source Surface and both surfaces are planar and oriented in a cardinal angle !");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "preventIncompleteSlices", label: "Prevent Incomplete Slices", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ cuttingGeoType == 0 } { surfaceOutput == 0 } { inputGeoType == 1 cuttingGeoType == 2 surfaceOutput == 1 surfaceCuttingMethod == 1 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType == 0 }");
			hou_parm_template2.setHelp("Cuts performed using the \"Poly Split\" Surface Cutting Method need to be continuous, so it at least needs to touch the edges of the primitive it tries to cut on both ends of the cut. With this enabled, slices that do not conform to these criteria are ignored.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "sliceEdgesNBGrpSelection", label: "Slice Edges Neighbouring the Source Group", default_value: true});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ inputGeoType == 0 }");
			hou_parm_template2.setHelp("When enabled, if a source geometry group is selected, also cuts the edges of the non-selected geometry that intersect with a cut. This keeps the geometry clean and intact. Also propagates edge and point groups to non-selected geometry.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "cuspCutEdges", label: "Cusp Cut Edges", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ inputGeoType == 1 surfaceOutput == 0 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType == 0 } { cuttingGeoType == 0 }");
			hou_parm_template2.setHelp("When enabled, cusps the cut edges on surfaces, spliting the geometry at the cut. When a Source group is used and \"Slice Edges Neighbouring Source Geo Groups\" is enabled, it also cusps the edge between grouped and non-grouped geometry to ensure proper cusping.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "cuspCutPoints", label: "Cusp Cut Points", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType != 0 }");
			hou_parm_template2.setHelp("When enabled, Cusps the cut points on a polyline, seperating the geometry at the cut.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.SeparatorParmTemplate({name: "sepparm2"});
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_toolprecision", label: "Tool Precision", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "simple"});
			hou_parm_template2 = new hou.FolderParmTemplate({name: "fd_polysplitprecision", label: "PolySplit Precision", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "simple"});
			hou_parm_template2.setTabConditional(hou.parmCondType.HideWhen, "{ inputGeoType == 1 cuttingGeoType == 2 surfaceCuttingMethod == 1 }");
			let hou_parm_template3 = new hou.IntParmTemplate({name: "highPrecisionMode", label: "High Precision Mode [Experimental]", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 2 }");
			hou_parm_template3.hide(true);
			hou_parm_template3.setHelp("When enabled, all tolerance and snapping values are set to very low levels. Creating cleaner cuts, but disables snapping.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.LabelParmTemplate({name: "PointCutHelp2", label: "PointCutHelp2", column_labels: ["Point Cutting: Snap distance should be high enough to detect intersections with the Source Geo."]});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 0 }");
			hou_parm_template3.setTags({"sidefx::look": "block"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.LabelParmTemplate({name: "EdgeCutHelp2", label: "EdgeCutHelp2", column_labels: ["Polyline Cutting: Snap distance needs to be high enough to detect intersections if Geo does not perfectly overlap."]});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 1 }");
			hou_parm_template3.setTags({"sidefx::look": "block"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.LabelParmTemplate({name: "SurfaceCutHelp2", label: "SurfaceCutHelp2", column_labels: ["Surface Cutting: the Snap distance should be set low enough to prevent over-snapping."]});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType != 1 } { cuttingGeoType != 2 }");
			hou_parm_template3.setTags({"sidefx::look": "block"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.IntParmTemplate({name: "highPrecisionPolysplit", label: "Boost Slice Sensitivity For Micro-scale or Dense Inputs", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ highPrecisionMode == 1 } { autoPrecisionCorrection == 1 } { surfaceOutput == 0 } { inputGeoType == 0 }");
			hou_parm_template3.hide(true);
			hou_parm_template3.setHelp("When enabled, makes the PolySplit SOP inside the asset more sensitive. This can be enabled when very dense cutting splines or surfaces are used. However, higher sensitivity may cause some cuts to fail or overcut if the cutting geometry is too large. Best to enable when cuts have detail smaller than 0.01 meters. Is enabled by default in High Precision Mode.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.SeparatorParmTemplate({name: "sepparm12"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "autoPrecisionCorrection", label: "Auto Precision Correction", default_value: true});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ cuttingGeoType == 2 highPrecisionMode == 1 }");
			hou_parm_template3.setJoinWithNext(true);
			hou_parm_template3.setHelp("When enabled, automatically clamps internal values based on the median sizes of the input geometry. This helps to regulate the snapping stength relative to the geometry scale and density provided. Be aware that manually set snapping values that are set too high or low compared to the Source Input scale, may cause bad cuts or model collapse along cuts. ( To be improved in v2.0 ). The exact formula for this is: The minimum value between [Input 1] Median Edge Length & [Input 2] Median Edge Length, multiplied by 0.1. Disable this function to manually set snapping values.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "autoNonPlanarCorrection", label: "Auto Correct Non-Planar Tolerance", default_value: false});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ cuttingGeoType == 2 highPrecisionMode == 1 } { autoPrecisionCorrection == 0 }");
			hou_parm_template3.setJoinWithNext(true);
			hou_parm_template3.setHelp("When enabled, automatically boosts Non-Planar Tolerance values based on the median sizes of the input geometry. Attempts to correct settings for non-planar geometry when cutting complex surfaces with surfaces of different sizes. Less suitable for simple planar geometry, in which case it is best practice to keep this option disabled and set the Non-Planar Tolerance manually. The exact formula for this is: The \"Non-Planar Tolerance\", multiplied by Square root of the [Input 1] Median Edge Length, multiplied by 1000. Disable this function to manually set Multiplication values for Non-Planar Tolerance.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.MenuParmTemplate({name: "autoPrecisionCorrectionLimit", label: "|", menu_items: ["0", "1"], menu_labels: ["Correct Upper and Lower Limit", "Correct Upper Limit"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ autoPrecisionCorrection == 0 }");
			hou_parm_template3.setHelp("In most cases, \"Auto Precision Correction’s\" upper and lower limits are designed to support models at a wide range of scales by automatically detecting the median sizes of a models primitives. However, if a model has a large discrepancy between its primitives surface areas, Auto correction may overcorrect. This setting can disable some of the limits such as the lower limit, to not clamp Snapping values unnecessarily.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "fd_aspfeedback", label: "ASP Feedback", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "simple", "sidefx::look": "blank"});
			let hou_parm_template4 = new hou.LabelParmTemplate({name: "messageAutoCorrection2", label: "messageAutoCorrection2", column_labels: ["Auto Correction - Snap Dist: [`ceil( ch(\"snapCtrl/snapDist\") * 10000000 )/10000000`]     Intersect Dist: [`ceil( ch(\"snapCtrl/proxTol\") * 10000000 )/10000000`]     Non-Planar Depth:[`ceil(ch(\"snapCtrl/nonPlanarTol\")*10000)/10000`]\n"]});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ autoPrecisionCorrection == 0 } { cuttingGeoType == 2 highPrecisionMode == 1 }");
			hou_parm_template4.setTags({"sidefx::look": "block"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.LabelParmTemplate({name: "messageHighPrecisionMode2", label: "messageHighPrecisionMode2", column_labels: ["High Precision - Snap Dist: [`ch(\"snapCtrl/snapDist\")`]     Intersect Dist: [`ch(\"snapCtrl/proxTol\")`]\n"]});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType != 2 } { highPrecisionMode == 0 }");
			hou_parm_template4.setTags({"sidefx::look": "block"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.SeparatorParmTemplate({name: "sepparm9"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "snapDist", label: "Snap Distance", num_components: 1, default_value: [0.001], min: 0, max: 1, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ highPrecisionMode == 1 cuttingGeoType == 2 }");
			hou_parm_template3.setHelp("Set the distance for cutting geometry to snap to the source geometry. When cutting with points or polylines it helps register cuts, when the distance falls within this value. Even if the cutting geometry is not exactly on the source geometry. When cutting with surfaces this helps avoid sliver cuts in corners by snapping the cuts to the geometry. When precise cuts must be made, smaller values produce higher levels of precision. In v1.0 high snap values can cause the model to collapse along cuts, best kept at reasonable levels. This is to be addressed in v2.0. By default, also sets the Intersect Tolerance unless manually overwritten. Automatically adjusted when Auto Precision Correction is enabled.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "proxTolTgl", label: "Intersect Tolerance    ", default_value: false});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ highPrecisionMode == 1 cuttingGeoType == 2 }");
			hou_parm_template3.setJoinWithNext(true);
			hou_parm_template3.setHelp("When enabled, allows for a seperate Intersection Tolerance from the snapping distance.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "proxtol", label: "proxtol", num_components: 1, default_value: [0.01], min: 0, max: 1, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ highPrecisionMode == 1 cuttingGeoType == 2 } { proxTolTgl == 0 }");
			hou_parm_template3.hideLabel(true);
			hou_parm_template3.setHelp("Determines the distance for points to detect an intersection between Input 1 and 2. Smaller values produce higher levels of precision. Works best if matching the Snap Distance, only change when required.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "LimitProxTol", label: "Disable Tolerance for Polyline Intersection Checks", default_value: false});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ cuttingGeoType == 0 } { inputGeoType == 1 cuttingGeoType == 2 }");
			hou_parm_template3.setHelp("This value disables the Intersection Tolerance for all polyline intersection checks. Normally, these intersection checks are limited by a tolerance value. However, in some cases, especially with very dense cutting geometries, it may fail to detect intersections. Turning this off changes the checking behavior, but REQUIRES that both input geometries overlap perfectly and are planar to a cardinal world axis. Intersection Tolerance is enabled by default.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "fd_booleanprecision", label: "Boolean Precision", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "simple"});
			hou_parm_template2.setTabConditional(hou.parmCondType.HideWhen, "{ inputGeoType != 1 } { cuttingGeoType != 2 } { surfaceCuttingMethod != 1 }");
			hou_parm_template3 = new hou.FloatParmTemplate({name: "lengththreshold", label: "Edge Length Threshold", num_components: 1, default_value: [1e-05], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("When in Boolean Shatter Mode, Allows tiny edges to be collapsed if under this length. Best kept at low values to avoid holes in the mesh. Also drives the precision of point injection to unselected geometry adjacent to a cut.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm8"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "nonPlanarTol", label: "Non-Planar Tolerance", num_components: 1, default_value: [2], min: 1e-08, max: 20, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("When cutting Non-Planar Surfaces, boosts the detection of primitives and edges overlapping the cuts. Allows mid-primitive points and cuts to detect their surfaces by this multiplication of the Intersection Tolerance. Is also used when transferring edge groups back to the source mesh after cutting, to ensure a proper transfer on Non-Planer surfaces & Non-Linear edges. High values may over-cut when paired with high Snap Dist values. Acts like a multiplier when Auto Correct Non-Planar Tolerance is enabled.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "pointSnapPrecisionFactor", label: "Point Snap Factor", num_components: 1, default_value: [1], min: 0, max: 10, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ inputGeoType == 1 cuttingGeoType == 2 surfaceOutput == 1 surfaceCuttingMethod == 1 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ highPrecisionMode == 1 cuttingGeoType == 2 }");
			hou_parm_template2.setHelp("    Modifies the snapping strength to source geometry points by this value to a power of 10. When making very fine Cuts on the edges of a primitive, cuts in corners may be allowed to be so tiny they fall outside the tolerance values, which could result in tiny uncut primitive corners. By forcing a second point snap at a higher snapping strength, these uncut corners are collapsed to their nearby corner points. Beware, over-use may collapse cuts.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "pointSnapPrecisionFactorHP", label: "Point Snap Factor", num_components: 1, default_value: [1], min: 0, max: 10, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ inputGeoType == 1 cuttingGeoType == 2 surfaceOutput == 1 surfaceCuttingMethod == 1 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ highPrecisionMode == 0 } { cuttingGeoType != 2 }");
			hou_parm_template2.hide(true);
			hou_parm_template2.setHelp("Increases the snapping strength to source points of this value to a power of 10. When making very fine Cuts on the edges of a primitive, cuts in corners may be allowed to be so tiny they fall outside the tolerance values, which would result in tiny uncut primitive corners. By forcing a second point snap at a higher snapping strength, these uncut corners are collapsed to their nearby corner points.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "cutPrecisionFactor", label: "Cut Precision Factor", num_components: 1, default_value: [1], min: 1, max: 4, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.hide(true);
			hou_parm_template2.setHelp("Increases the snapping strength of Points in the middle of a cut to Source points of this value to a power of 10. Can be used to prevents tiny cuts from causing errors.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.SeparatorParmTemplate({name: "sepparm7"});
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_groupsoutput", label: "Groups Output", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "simple"});
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "edgeGroupTgl", label: "Output Edge Group", default_value: false});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "prim_Group_Name", label: "Cut Edge Group", num_components: 1, default_value: ["cut"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ edgeGroupTgl == 0 }");
			hou_parm_template2.setHelp("Set the edge group for any cuts the tool makes on surfaces.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "avoidGroupingIncompleteAutoSlices", label: "Avoid Grouping Incomplete Auto-Slices", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ edgeGroupTgl == 0 } { preventIncompleteSlices == 1 }");
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ inputGeoType == 1 cuttingGeoType == 2 surfaceCuttingMethod == 1 }");
			hou_parm_template2.setHelp("When incomplete slices are allowed, the connecting slice will be added to the edge group. When this option is enabled, it tries to auto-exclude this edge from that group.  Also affects Edge Cusping.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm3"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "pointGroup_Tgl", label: "pointGroup_Tgl", default_value: false});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Mark Cut Intersections with this point group.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "pointGroup_Group", label: "Cut Point Group", num_components: 1, default_value: ["cutPoint"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ pointGroup_Group == 0 } { pointGroup_Tgl == 0 }");
			hou_parm_template2.setHelp("Mark Cut Intersections with this point group.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "snapped_Tgl", label: "snapped_Tgl", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ inputGeoType == 1 cuttingGeoType == 2 surfaceOutput == 1 surfaceCuttingMethod == 1 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Mark Points on cuts that have their Points Snapped to nearby points on the source geometry with this point group. ");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "snapped_Group", label: "Snap Point Group", num_components: 1, default_value: ["cutSnapped"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ outputPrGrp == 0 } { snapped_Tgl == 0 } { inputGeoType == 1 cuttingGeoType == 2 surfaceOutput == 1 surfaceCuttingMethod == 1 }");
			hou_parm_template2.setHelp("Mark Points on cuts that have their Points Snapped to nearby points on the source geometry with this point group. ");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "center_Tgl", label: "Output Prim Group", default_value: false});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "center_Group", label: "Center Point Group", num_components: 1, default_value: ["cutIntersection"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ outputPrGrp == 0 } { center_Tgl == 0 }");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm11"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "filterEdgeGroups", label: "Preserve Edge Groups", num_components: 1, default_value: ["*"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a getIntrinsicEdgeGroups group", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setHelp("Filter which edge groups are preserved between the source input and output. If this field is empty or *, all edge groups are preserved, but the copying process could be costly if a lot of edge groups exist on the geometry.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.SeparatorParmTemplate({name: "sepparm4"});
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_cleanup", label: "Cleanup", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "sortByConnectivityID", label: "Sort Primitives by Connectivity ID", default_value: false});
			hou_parm_template2.setHelp("When enabled, upon output sorts the primitive order along the connectivity ID order.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "sortByVertexOrder", label: "Sort Points By Vertex Order", default_value: false});
			hou_parm_template2.setHelp("When enabled, upon output sorts the point order along the vertex order.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "recomputeNormals", label: "Post-Compute Normals", default_value: false});
			hou_parm_template2.setHelp("When enabled, re-computes the normals on the entire mesh, otherwise, tries to approximate the original normals from the source input.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "fd_normals", label: "Normals", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "simple"});
			hou_parm_template2.setTabConditional(hou.parmCondType.HideWhen, "{ recomputeNormals == 0 }");
			hou_parm_template3 = new hou.MenuParmTemplate({name: "normalType", label: "Normal Type", menu_items: ["typepoint", "typevertex", "typeprim"], menu_labels: ["Points", "Vertices", "Primitives"], default_value: 1, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setHelp("Sets the element type to write the normals to.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "cuspangle", label: "Cusp Angle", num_components: 1, default_value: [60], min: 0, max: 180, min_is_strict: true, max_is_strict: true, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("The angle at which recomputed normals switch from soft to hard normals.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.IntParmTemplate({name: "method", label: "Weighting Method", num_components: 1, default_value: [2], min: 0, max: 2, min_is_strict: true, max_is_strict: true, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: ["uniform", "angle", "area"], menu_labels: ["Each Vertex Equally", "By Vertex Angle", "By Face Area"], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template3.setHelp("This sets the method by which the normals are computed.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.SeparatorParmTemplate({name: "sepparm5"});
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_visualfeedbackperformance", label: "Visual Feedback & Performance", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "meshConnectionID_Tgl", label: "meshConnectionID_Tgl", default_value: false});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "inputConnectionID_Attrib", label: "Input Connection ID", num_components: 1, default_value: ["meshConnection_ID"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ meshConnectionID_Tgl == 0 }");
			hou_parm_template2.setHelp("When enabled, writes the Mesh Connectivity ID from the Source Input under the specified primitive attribute name.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "outputConnectivity", label: "Display Output Connectivity as Primitive Color", default_value: false});
			hou_parm_template2.setHelp("Use this to debug and display the connectivity of the meshes for the Poly Scalpel Output. Can be used to debug bad cuts or to display disconnected segments. Is distinct from the Input Connectivity ID. Overwrites all Color attributes on the mesh with a primitive color attribute.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "seed", label: "Color Seed", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ outputConnectivity == 0 }");
			hou_parm_template2.setHelp("Seed value for the Output Connectivity Color.");
			hou_parm_template2.setTags({"autoscope": "0000000000000000"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm13"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "displayCuttingGuide", label: "Always Display Cutting Guide", default_value: true});
			hou_parm_template2.setHelp("When the node is rendered, always display a guide geometry wireframe to show where the cutting geometry is. Only displays cross cut guides when disabled.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm10"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "doCompile", label: "Enable Compiling Inside Assets", default_value: true});
			hou_parm_template2.setHelp("Enable Compiling for most of this asset, speeds up the Utility");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			
            this.parmTemplateGroup = hou_parm_template_group;
            this.parmTemplateGroup.linkNode(this);
        }
    }
    hou.registerType('SOP/Labs/Geometry/Mesh: Cut/Labs::polyscalpel::1.0',_hnt_SOP_Labs__polyscalpel__1_0)
    return _hnt_SOP_Labs__polyscalpel__1_0
}
        