
export default function (hou) {
    class _hnt_VOP_pxrsurface extends hou._HoudiniBase {
        static is_root = false;
        static id = 'VOP/Other/pxrsurface';
        static category = '/VOP';
        static houdiniType = 'pxrsurface';
        static title = 'Pxr Surface';
        static icon = '/editor/assets/imgs/nodes/_hnt_VOP_pxrsurface.svg';
        constructor() {
            super();
            this.flags['houdini_type'] = this.__proto__.constructor.houdiniType;
            
            const inputs = ['VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP', 'VOP'];
            const outputs = ['VOP'];

            for(var i=0;i<inputs.length;i++) this.addInput(''+i,inputs[i]);        
            for(var j=0;j<outputs.length;j++) this.addOutput(''+j,outputs[j]);
        }
        parmTemplatesInit() {
            let hou_parm_template_group = new hou.ParmTemplateGroup();
			this.parmTemplateGroup = hou_parm_template_group;
			let hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group", label: "Layer", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template.hide(true);
			let hou_parm_template2 = new hou.LabelParmTemplate({name: "pxrlayer", label: "Layer", column_labels: [""]});
			hou_parm_template2.hide(true);
			hou_parm_template2.setTags({"script_ritype": "struct"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_1", label: "Diffuse", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FloatParmTemplate({name: "diffuseGain", label: "Gain", num_components: 1, default_value: [1], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Diffuse gain. This is a multiplier for the diffuse lobe.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "diffuseColor", label: "Color", num_components: 3, default_value: [0.18, 0.18, 0.18], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setHelp("Diffuse color. This sets the color for the diffuse lobe.");
			hou_parm_template2.setTags({"ogl_diff": "1", "script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "diffuseRoughness", label: "Roughness", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Diffuse roughness (OrenNayar model). The higher the number, the rougher it gets.");
			hou_parm_template2.setTags({"ogl_rough": "1", "script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "diffuse_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			let hou_parm_template3 = new hou.FloatParmTemplate({name: "diffuseExponent", label: "Exponent", num_components: 1, default_value: [1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ diffuseRoughness != 0 }");
			hou_parm_template3.setHelp("Diffuse falloff exponent. This is for Lambertian model only, i.e. when diffuse roughness is 0.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "diffuseBumpNormal", label: "Bump", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template3.setHelp("Connect a PxrBump node here if you need bump or normal-mapped normals for the diffuse lobe instead of using the normal bump in the Globals. Only valid when provided as a texture/connection.");
			hou_parm_template3.setTags({"script_ritype": "normal"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "diffuseDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template3.setHelp("If on, illuminate on both sides of the surface for this diffuse lobe.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "diffuseBackUseDiffuseColor", label: "Use Diffuse Color", default_value: true});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ diffuseDoubleSided != 1 }");
			hou_parm_template3.setHelp("If on, the back side will use the regular Diffuse Color. Turn it off to enable a specific Back Color field.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "diffuseBackColor", label: "Back Color", num_components: 3, default_value: [0.18, 0.18, 0.18], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ diffuseDoubleSided != 1 } { diffuseBackUseDiffuseColor != 0 }");
			hou_parm_template3.setHelp("Diffuse back color.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "diffuseTransmitGain", label: "Transmit Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ diffuseDoubleSided != 1 }");
			hou_parm_template3.setHelp("This only applies when Double Sided is on. Instead of using Diffuse Gain for controlling the intensity of the diffuse transmission, we use Diffuse Transmit Gain. If it is set to 0.0, the diffuse transmission is off.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "diffuseTransmitColor", label: "Transmit Color", num_components: 3, default_value: [0.18, 0.18, 0.18], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ diffuseDoubleSided != 1 }");
			hou_parm_template3.setHelp("This only applies when Double Sided is on. This sets the color for diffuse transmission.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_2", label: "Specular", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FolderParmTemplate({name: "primary_specular", label: "Primary Specular", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.MenuParmTemplate({name: "specularFresnelMode", label: "Specular Fresnel Mode", menu_items: ["0", "1"], menu_labels: ["Artistic", "Physical"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setHelp("Artistic mode uses Face and Edge Color and Fresnel Exponent. Physical mode uses Refractive Index and Extinction Coefficient as in PxrLM Bxdf.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularFaceColor", label: "Face Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ specularFresnelMode != 0 }");
			hou_parm_template3.setHelp("Specular color at 0 degree incidence. This is the specular color for facing the camera.");
			hou_parm_template3.setTags({"ogl_spec": "1", "script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularEdgeColor", label: "Edge Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Specular color at 90 degree incidence. This is the specular color for the glancing angle on the edge.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularFresnelShape", label: "Fresnel Exponent", num_components: 1, default_value: [5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ specularFresnelMode != 0 }");
			hou_parm_template3.setHelp("Specular Fresnel curve exponent. 5.0 is a good default. This is normaly unchanged. If changed, this affects the face and edge falloff.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularIor", label: "Refraction Index", num_components: 3, default_value: [1.5, 1.5, 1.5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ specularFresnelMode != 1 }");
			hou_parm_template3.setHelp("Refractive Index is the dielectric index of refraction for the material. Channel values for this parameter typically lie in the range 1 - 3. Since we support 3 color values to capture the spectral effect presets may be preferred over color pickers.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularExtinctionCoeff", label: "Extinction Coefficient", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ specularFresnelMode != 1 }");
			hou_parm_template3.setHelp("Extinction Coefficient is a second refractive index for the material useful for characterizing metallic behaviors. Channel values for this parameter typically lie in the range 1 - 3. Since we support 3 color values to capture the spectral effect presets may be prefered over color pickers. When 0, the material reacts as a dielectric (glass, clearcoat)> When non-zero, the material responds as a conductor would.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularRoughness", label: "Roughness", num_components: 1, default_value: [0.2], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Specular roughness. The higher the number, the rougher it gets. The range is between 0 to 1. Negative number is not allowed.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "primary_specular_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			let hou_parm_template4 = new hou.MenuParmTemplate({name: "specularModelType", label: "Specular Model", menu_items: ["0", "1"], menu_labels: ["Beckmann", "Ggx"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template4.setHelp("Select a specular model. Both are competitively good models. If you need to match the look to existing PxrLM Bxdf, use Ggx because PxrLM is hard coded to use Ggx. Beckmann highlight is sharper while Ggx highlight provides softer falloff. There is no set rule, pick the model which delivers the targeted visual result you are after.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "specularAnisotropy", label: "Anisotropy", num_components: 1, default_value: [0], min: null, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Controls the shape of the specular highlights and reflections. At 0 the shape is circular. Values from -1 to 1 produce the range of ellipses from fat to tall. The direction of anisotropy can also be controlled by your model texture parameters and by the Shading Tangent parameter.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "specularAnisotropyDirection", label: "Shading Tangent", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template4.setHelp("Controls the anisotropy direction. Only valid when provided as a texture/connection.");
			hou_parm_template4.setTags({"script_ritype": "vector"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "specularBumpNormal", label: "Bump", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template4.setHelp("Connect a PxrBump node here if you need bump or normal-mapped normals for the specular lobe instead of using the normal bump in the Globals. Only valid when provided as a texture/connection.");
			hou_parm_template4.setTags({"script_ritype": "normal"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "specularDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template4.setHelp("If on, illuminate on both sides of the surface for this specular lobe.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "rough_specular", label: "Rough Specular", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.MenuParmTemplate({name: "roughSpecularFresnelMode", label: "Specular Fresnel Mode", menu_items: ["0", "1"], menu_labels: ["Artistic", "Physical"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setHelp("Artistic mode uses Face and Edge Color and Fresnel Exponent. Physical mode uses Refractive Index and Extinction Coefficient as in PxrLM Bxdf.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "roughSpecularFaceColor", label: "Face Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ roughSpecularFresnelMode != 0 }");
			hou_parm_template3.setHelp("Specular color at 0 degree incidence. This is the specular color for facing the camera.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "roughSpecularEdgeColor", label: "Edge Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Specular color at 90 degree incidence. This is the specular color for the glancing angle on the edge.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "roughSpecularFresnelShape", label: "Fresnel Exponent", num_components: 1, default_value: [5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ roughSpecularFresnelMode != 0 }");
			hou_parm_template3.setHelp("Specular Fresnel curve exponent. 5.0 is a good default. This is normaly unchanged. If changed, this affects the face and edge falloff.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "roughSpecularIor", label: "Refraction Index", num_components: 3, default_value: [1.5, 1.5, 1.5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ roughSpecularFresnelMode != 1 }");
			hou_parm_template3.setHelp("Refractive Index is the dielectric index of refraction for the material. Channel values for this parameter typically lie in the range 1 - 3. Since we support 3 color values to capture the spectral effect presets may be preferred over color pickers.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "roughSpecularExtinctionCoeff", label: "Extinction Coefficient", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ roughSpecularFresnelMode != 1 }");
			hou_parm_template3.setHelp("Extinction Coefficient is a second refractive index for the material useful for characterizing metallic behaviors. Channel values for this parameter typically lie in the range 1 - 3. Since we support 3 color values to capture the spectral effect presets may be prefered over color pickers. When 0, the material reacts as a dielectric (glass, clearcoat)> When non-zero, the material responds as a conductor would.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "roughSpecularRoughness", label: "Roughness", num_components: 1, default_value: [0.6], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Specular roughness. The higher the number, the rougher it gets. The range is between 0 to 1. Negative number is not allowed.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "rough_specular_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.MenuParmTemplate({name: "roughSpecularModelType", label: "Specular Model", menu_items: ["0", "1"], menu_labels: ["Beckmann", "Ggx"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template4.setHelp("Select a specular model. Both are competitively good models. If you need to match the look to existing PxrLM Bxdf, use Ggx because PxrLM is hard coded to use Ggx. Beckmann highlight is sharper while Ggx highlight provides softer falloff. There is no set rule, pick the model which delivers the targeted visual result you are after.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "roughSpecularAnisotropy", label: "Anisotropy", num_components: 1, default_value: [0], min: null, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Controls the shape of the specular highlights and reflections. At 0 the shape is circular. Values from -1 to 1 produce the range of ellipses from fat to tall. The direction of anisotropy can also be controlled by your model texture parameters and by the Shading Tangent parameter.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "roughSpecularAnisotropyDirection", label: "Shading Tangent", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template4.setHelp("Controls the anisotropy direction. Only valid when provided as a texture/connection.");
			hou_parm_template4.setTags({"script_ritype": "vector"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "roughSpecularBumpNormal", label: "Bump", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template4.setHelp("Connect a PxrBump node here if you need bump or normal-mapped normals for the rough specular lobe instead of using the normal bump in the Globals. Only valid when provided as a texture/connection.");
			hou_parm_template4.setTags({"script_ritype": "normal"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "roughSpecularDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template4.setHelp("If on, illuminate on both sides of the surface for this specular lobe.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "clear_coat", label: "Clear Coat", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.MenuParmTemplate({name: "clearcoatFresnelMode", label: "Specular Fresnel Mode", menu_items: ["0", "1"], menu_labels: ["Artistic", "Physical"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setHelp("Artistic mode uses Face and Edge Color and Fresnel Exponent. Physical mode uses Refractive Index and Extinction Coefficient as in PxrLM Bxdf.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatFaceColor", label: "Face Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ clearcoatFresnelMode != 0 }");
			hou_parm_template3.setHelp("Clearcoat color at 0 degree incidence. This is the clearcoat color for facing the camera.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatEdgeColor", label: "Edge Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Clearcoat color at 90 degree incidence. This is the clearcoat color for the glancing angle on the edge.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatFresnelShape", label: "Fresnel Exponent", num_components: 1, default_value: [5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ clearcoatFresnelMode != 0 }");
			hou_parm_template3.setHelp("Clearcoat Fresnel curve exponent. 5.0 is a good default. This is normaly unchanged. If changed, this affects the face and edge falloff.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatIor", label: "Refraction Index", num_components: 3, default_value: [1.5, 1.5, 1.5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ clearcoatFresnelMode != 1 }");
			hou_parm_template3.setHelp("Refractive Index is the dielectric index of refraction for the material. Channel values for this parameter typically lie in the range 1 - 3. Since we support 3 color values to capture the spectral effect presets may be preferred over color pickers.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatExtinctionCoeff", label: "Extinction Coefficient", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ clearcoatFresnelMode != 1 }");
			hou_parm_template3.setHelp("Extinction Coefficient is a second refractive index for the material useful for characterizing metallic behaviors. Channel values for this parameter typically lie in the range 1 - 3. Since we support 3 color values to capture the spectral effect presets may be prefered over color pickers. When 0, the material reacts as a dielectric (glass, clearcoat)> When non-zero, the material responds as a conductor would.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatRoughness", label: "Roughness", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Clearcoat roughness. The higher the number, the rougher it gets. The range is between 0 to 1. Negative number is not allowed.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "clear_coat_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.MenuParmTemplate({name: "clearcoatModelType", label: "Specular Model", menu_items: ["0", "1"], menu_labels: ["Beckmann", "Ggx"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template4.setHelp("Select a specular model. Both are competitively good models. If you need to match the look to existing PxrLM Bxdf, use Ggx because PxrLM is hard coded to use Ggx. Beckmann highlight is sharper while Ggx highlight provides softer falloff. There is no set rule, pick the model which delivers the targeted visual result you are after.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "clearcoatAnisotropy", label: "Anisotropy", num_components: 1, default_value: [0], min: null, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Controls the shape of the specular highlights and reflections. At 0 the shape is circular. Values from -1 to 1 produce the range of ellipses from fat to tall. The direction of anisotropy can also be controlled by your model texture parameters and by the Shading Tangent parameter.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "clearcoatAnisotropyDirection", label: "Shading Tangent", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template4.setHelp("Controls the anisotropy direction. Only valid when provided as a texture/connection.");
			hou_parm_template4.setTags({"script_ritype": "vector"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "clearcoatBumpNormal", label: "Bump", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template4.setHelp("Connect a PxrBump node here if you need bump or normal-mapped normals for the clearcoat lobe instead of using the normal bump in the Globals. Only valid when provided as a texture/connection.");
			hou_parm_template4.setTags({"script_ritype": "normal"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "clearcoatDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template4.setHelp("If on, illuminate on both sides of the surface for this clearcoat lobe.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "specular_clearcoat_globals", label: "Specular Clearcoat Globals", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "specularEnergyCompensation", label: "Specular Energy Compen", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("When this is set to > 0.0, it applies energy compensation to the diffuse and subsurface illumination. This is a view dependent fresnel energy compensation. This effect is visible when we have a low specular face color and high edge color. A value of 1.0 attempts to fully balance those illuminations by darkening them against the specular and rough specular illumination responses. Specular and Rough Specular roughness are also taken into account. The effect fades off as specular face or edge color approaches 1.0.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "clearcoatEnergyCompensation", label: "Clearcoat Energy Compen", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("When clearcoat energy compensation is set to > 0.0, it applies energy compensation to all the lobes other than the clearcoat itself. We assume clearcoat is the layer above diffuse, subsurface, and specular. This is a view dependent fresnel energy compensation. This effect is visible when we have a low clearcoat face color and high edge color. A value of 1.0 attempts to fully balance those illums by darkening them against the clearcoat illumination response. Clearcoat roughness is also taken into account. The effect fades off as clearcoat face or edge color approaches 1.0.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_3", label: "Iridescence", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FloatParmTemplate({name: "iridescenceFaceGain", label: "Face gain", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Iridescence gain at 0 degree incidence. This is the iridescence gain for facing the camera.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "iridescenceEdgeGain", label: "Edge gain", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Iridescence gain at 90 degree incidence. This is the iridescence gain for the glancing angle on the edge.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "iridescenceFresnelShape", label: "Fresnel Exponent", num_components: 1, default_value: [5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Iridescence fresnel curve exponent. 5.0 is a good default. This is normally unchanged. If changed, this affects the face and edge falloff.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "iridescenceMode", label: "iridescenceMode", menu_items: ["0", "1"], menu_labels: ["Artistic", "Physical"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("In Artistic mode, we just set 2 colors. Depending on the iridescence scale factor, we will see N number of 'rainbows'. In Physical mode, we pass the thickness of your thin film in nanometer. The iridescence effect happens when the physical thickness is close to the visible spectrum. You can start around 800nm and increase the value to see the effect.");
			hou_parm_template2.setTags({"script_ritype": "int"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "iridescencePrimaryColor", label: "Primary Color", num_components: 3, default_value: [1, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ iridescenceMode != 0 }");
			hou_parm_template2.setHelp("Iridescence primary color on the hue wheel to start from.");
			hou_parm_template2.setTags({"script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "iridescenceSecondaryColor", label: "Secondary Color", num_components: 3, default_value: [0, 0, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ iridescenceMode != 0 }");
			hou_parm_template2.setHelp("Iridescence secondary color on the hue wheel to end at.");
			hou_parm_template2.setTags({"script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "iridescenceRoughness", label: "Roughness", num_components: 1, default_value: [0.2], min: 0.001, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Iridescence roughness. The higher the number, it rougher it gets. The range is between 0 to 1. Negative number is not allowed.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "iridescence_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "iridescenceCurve", label: "Falloff Speed", num_components: 1, default_value: [1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ iridescenceMode != 0 }");
			hou_parm_template3.setHelp("Falloff speed from Primary Color to Secondary Color. Bigger number falloffs slower.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "iridescenceScale", label: "Falloff Scale", num_components: 1, default_value: [1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ iridescenceMode != 0 }");
			hou_parm_template3.setHelp("Falloff Scale. This sets how many times the 'rainbows' repeat.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "iridescenceFlip", label: "Flip Hue Direction", default_value: false});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ iridescenceMode != 0 }");
			hou_parm_template3.setHelp("Flip the hue wheel direction between primary and secondary colors. By default, the hue wheel direction is counter clockwise.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "iridescenceThickness", label: "Thin Film Thickness", num_components: 1, default_value: [800], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ iridescenceMode != 1 }");
			hou_parm_template3.setHelp("Thin film thickness in nanometer.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "iridescenceDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template3.setHelp("If on, illuminate on both sides of the surface for this iridescence lobe.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_4", label: "Fuzz", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FloatParmTemplate({name: "fuzzGain", label: "Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Fuzz gain. This is a multiplier for the fuzz lobe.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "fuzzColor", label: "Color", num_components: 3, default_value: [1, 1, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setHelp("Fuzz color. This sets the color for the fuzz lobe.");
			hou_parm_template2.setTags({"script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "fuzzConeAngle", label: "Cone Angle", num_components: 1, default_value: [8], min: 0, max: 20, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Since fuzz is a hair-like property, its roughness is controlled by a cone angle in degree which typically ranges from 6 to 20. It is in fact derived from PxrMarchnerHair's specular R lobe where it assumes each hair is oriented along the surface normal and is softened by multiplying LdotN.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "fuzz_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "fuzzBumpNormal", label: "Bump", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template3.setHelp("Connect a PxrBump node here if you need bump or normal-mapped normals for the fuzz lobe instead of using the normal bump in the Globals. Only valid when provided as a texture/connection.");
			hou_parm_template3.setTags({"script_ritype": "normal"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "fuzzDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template3.setHelp("If this is set, this normal will be used for the fuzz illumination instead of the bump normal set in the Globals.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_5", label: "Scattering", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FolderParmTemplate({name: "subsurface", label: "Subsurface", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.MenuParmTemplate({name: "subsurfaceType", label: "Subsurface Model", menu_items: ["0", "3", "1", "2", "5", "6"], menu_labels: ["Jensen Dipole", "DEon Better Dipole", "Burley Normalized", "Multiple Mean Free Paths", "Exponential Path Traced", "Non-Exponential Path Traced"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setHelp("Subsurface profile types. Jensen's dipole and d'Eon's better dipole profiles model subsurface diffusion, i.e. subsurface scattering after many bounces of scattering. Burley's normalized profile models both diffusion and single-scattering. Path traced implements brute-force Monte Carlo scattering.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceGain", label: "Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Subsurface gain. This is a multiplier on the subsurface lobe (subsurfaceColor).");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceColor", label: "Color", num_components: 3, default_value: [0.83, 0.791, 0.753], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Subsurface color. For the Jensen, dEon, and Burley models, this sets the color for the subsurface lobe. (For the Multiple Mean Free Paths subsurface scattering model this is the color of medium-distance scattering.)");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceDmfp", label: "Mean Free Path Distance", num_components: 1, default_value: [10], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Subsurface mean free path scalar distance. This specifies how far the light travels. It gets multiplied on the Mean Free Path Color below.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceDmfpColor", label: "Mean Free Path Color", num_components: 3, default_value: [0.851, 0.557, 0.395], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType == 2 }");
			hou_parm_template3.setHelp("Subsurface mean free path color tint. This gets multiplied on subsurfaceDmfp to specify how far the light (in the red, green, and blue band) travels on average. (Only used by the Jensen, dEon, and Burley models; ignored for the Multiple Mean Free Paths model.)");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "shortSubsurfaceGain", label: "Short Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 2 }");
			hou_parm_template3.setHelp("This is only applicable to the Multiple Mean Free Paths subsurface scattering model. Gain for the short-range subsurface scattering color: multiplier on shortSubsurfaceColor.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "shortSubsurfaceColor", label: "Short Color", num_components: 3, default_value: [0.9, 0.9, 0.9], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 2 }");
			hou_parm_template3.setHelp("This is only applicable to the Multiple Mean Free Paths subsurface scattering model. Subsurface color for short-range subsurface scattering.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "shortSubsurfaceDmfp", label: "Short MFP Distance", num_components: 1, default_value: [5], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 2 }");
			hou_parm_template3.setHelp("This is only applicable to the Multiple Mean Free Paths subsurface scattering model. Mean free path length for short-range subsurface scattering.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "longSubsurfaceGain", label: "Long Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 2 }");
			hou_parm_template3.setHelp("This is only applicable to the Multiple Mean Free Paths subsurface scattering model. Gain for the long-range subsurface scattering color: multiplier on longSubsurfaceColor.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "longSubsurfaceColor", label: "Long Color", num_components: 3, default_value: [0.8, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 2 }");
			hou_parm_template3.setHelp("This is only applicable to the Multiple Mean Free Paths subsurface scattering model. Subsurface color for long-range subsurface scattering.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "longSubsurfaceDmfp", label: "Long MFP Distance", num_components: 1, default_value: [20], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 2 }");
			hou_parm_template3.setHelp("This is only applicable to the Multiple Mean Free Paths subsurface scattering model. Mean free path length for long-range subsurface scattering.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceDirectionality", label: "Directionality", num_components: 1, default_value: [0], min: 0, max: 0.95, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 5 subsurfaceType != 6 }");
			hou_parm_template3.setHelp("Anisotropy ('specularity') of the subsurface medium. Higher values makes light scatter predominantly forward.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceBleed", label: "Bleed", num_components: 1, default_value: [0], min: 0, max: 100, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 6 }");
			hou_parm_template3.setHelp("Controls the depth of light bleed in the subsurface medium. Has the effect of increasing the distance light travels in the medium while preserving fine detail, compared to increasing the Mean Free Path.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceZeroScatterAttenuation", label: "Zero Scatter Attenuation", num_components: 1, default_value: [0.5], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 5 subsurfaceType != 6 }");
			hou_parm_template3.setHelp("Attenuates zero-scatter events by narrowing the contribution cone along the entry direction. Helps avoid retroreflective effects in path traced subsurface scattering.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "subsurfaceDiffuseBlend", label: "Diffuse Blend", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 5 subsurfaceType != 6 }");
			hou_parm_template3.setHelp("Blends a diffuse component into the subsurface calculation. Useful on objects with very sharp edges where dark artifacts can be seen.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "subsurfaceResolveSelfIntersections", label: "Resolve Self Intersections", default_value: false});
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType != 5 subsurfaceType != 6 }");
			hou_parm_template3.setHelp("If the geometry has self-intersections, enabling this option will track the surfaces so that only the outer-most ones are active for subsurface light transport.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "subsurface_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.FloatParmTemplate({name: "subsurfacePostTint", label: "Post Tint", num_components: 3, default_value: [1, 1, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template4.setHelp("Tint that is applied at the end of the subsurface computation.");
			hou_parm_template4.setTags({"script_ritype": "color"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "subsurfaceDiffuseSwitch", label: "Diffuse Computation Switch", num_components: 1, default_value: [1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Switch the subsurface computation to a diffuse computation if the dmfp is smaller than the ray footprint.  This gives a useful speed-up for frontlit objects, but gives incorrect results for thin backlit objects where the subsurface scattering will traverse the object whereas diffuse will not.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "subsurfaceDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType == 5 } { subsurfaceType == 6 }");
			hou_parm_template4.setHelp("If on, illuminate on both sides of the surface for this subsurface lobe.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "subsurfaceTransmitGain", label: "subsurfaceTransmitGain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceDoubleSided != 1 }");
			hou_parm_template4.setHelp("This only applies when Double Sided is on. Instead of using Subsurface Gain for controlling the intensity of the subsurface transmission, we use Subsurface Transmit Gain. If it is set to 0.0, the subsurface transmission is off.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "subsurface_trace_control", label: "Trace Control", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "considerBackside", label: "Consider Backside", default_value: true});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType == 5 } { subsurfaceType == 6 }");
			hou_parm_template4.setHelp("Whether subsurface respects surfaces on the otherside. * 'Off' - It will ignore surfaces on the other side completely. This is useful to make objects appear thicker than they are. * 'On' - Normal mode, where the diffusion happens between the front and the first surface behind it.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.MenuParmTemplate({name: "continuationRayMode", label: "Continuation Ray Mode", menu_items: ["0", "1", "2"], menu_labels: ["Off", "Last Hit", "All Hits"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType == 5 } { subsurfaceType == 6 }");
			hou_parm_template4.setHelp("Control continuation ray mode. * 'Off' - Simply trace out of the object (default) * 'LastHit' - Ignore internal geometry and jump to the last surface * 'AllHits' - Scatter (collect light) on all hits as the ray leaves the object. This can bring additional brightness, at the cost of additional noise.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.IntParmTemplate({name: "maxContinuationHits", label: "Max Continuation Hits", num_components: 1, default_value: [2], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ continuationRayMode != 2 }");
			hou_parm_template4.setHelp("Maximum number of hits to test in all hits mode.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "followTopology", label: "Follow Topology", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ subsurfaceType == 5 } { subsurfaceType == 6 }");
			hou_parm_template4.setHelp("Controls how strongly normals are considered in the subsurface computation.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.StringParmTemplate({name: "subsurfaceSubset", label: "Trace Subset", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template4.setTags({"script_ritype": "string"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "single_scatter", label: "Single Scatter", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "singlescatterGain", label: "Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Single scatter gain. This is a multiplier for the single scatter lobe.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "singlescatterColor", label: "Color", num_components: 3, default_value: [0.83, 0.791, 0.753], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Single scatter color. This is the color for the single scatter lobe.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "singlescatterMfp", label: "Mean Free Path", num_components: 1, default_value: [10], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Single scatter mean free path scalar distance. This specifies how far the light travels. This gets multiplied to the Mean Free Path Color below.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "singlescatterMfpColor", label: "Mean Free Path Color", num_components: 3, default_value: [0.851, 0.557, 0.395], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Single scatter mean free path color. This specifies how far the light travels in the R, G and B spectra.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "single_scatter_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.FloatParmTemplate({name: "singlescatterDirectionality", label: "Directionality", num_components: 1, default_value: [0], min: null, max: 0.99, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Single scatter directionality (1: forward, -1: backward, 0:isotropic).");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "singlescatterIor", label: "Refractive Index", num_components: 1, default_value: [1.3], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Single scatter index of refraction.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "singlescatterBlur", label: "Blur", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Blur strength for single scatter.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "singlescatterDirectGain", label: "Backside Direct Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Gain for direct illumination from the other side.");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.FloatParmTemplate({name: "singlescatterDirectGainTint", label: "Direct Gain Tint", num_components: 3, default_value: [1, 1, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template4.setHelp("Tinting color for the direct gain.");
			hou_parm_template4.setTags({"script_ritype": "color"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "singlescatterDoubleSided", label: "Double Sided", default_value: false});
			hou_parm_template4.setHelp("If on, illuminate on both sides of the surface for this single scatter lobe.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "single_scatter_trace_control", label: "Trace Control", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "singlescatterConsiderBackside", label: "Consider Backside", default_value: true});
			hou_parm_template4.setHelp("Whether single scatter respects surfaces on the otherside. * 'Off' - It will ignore surfaces on the other side completely. This is useful to make objects apear thicker than they are. * 'On' - Normal mode, where the scattering happens between the front and the first surface behind it.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.MenuParmTemplate({name: "singlescatterContinuationRayMode", label: "Continuation Ray Mode", menu_items: ["0", "1", "2"], menu_labels: ["Off", "Last Hit", "All Hits"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template4.setHelp("Control continuation ray mode. * 'Off' - Simply trace out of the object (default) * 'LastHit' - Ignore internal geometry and jump to the last surface * 'AllHits' - Scatter (collect light) on all hits as the ray leaves the object. This can bring additional brightness, at the cost of additional noise.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.IntParmTemplate({name: "singlescatterMaxContinuationHits", label: "Max Continuation Hits", num_components: 1, default_value: [2], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template4.setConditional(hou.parmCondType.HideWhen, "{ singlescatterContinuationRayMode != 2 }");
			hou_parm_template4.setHelp("Maximum number of hits to test in all hits mode.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.MenuParmTemplate({name: "singlescatterDirectGainMode", label: "Direct Gain Mode", menu_items: ["0", "1", "2"], menu_labels: ["First Hit", "Last Hit", "All Hits"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template4.setHelp("Control the continuation ray mode for direct gain. * 'FirstHit' - Simply trace to the next surface (this is tied to considerBackside) * 'LastHit' - Ignore internal geometry and jump to the last surface * 'AllHits' - Scatter (collect light) on all hits as the ray leaves the object. This can bring additional brightness, at the cost of additional noise.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.StringParmTemplate({name: "singlescatterSubset", label: "Trace Subset", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal});
			hou_parm_template4.setTags({"script_ritype": "string"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "scattering_globals", label: "Scattering Globals", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "irradianceTint", label: "Irradiance Tint", num_components: 3, default_value: [1, 1, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("A tint applied to illumination before being scattered by subsurface or single scatter.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "irradianceRoughness", label: "Irradiance Roughness", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Diffuse roughness (OrenNayar model) to be applied for subsurface or single scatter.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "unitLength", label: "Unit Length", num_components: 1, default_value: [0.1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Subsurface and single scatter unit length. It is a multiplier on Mean Free Path Distance. Mean Free Path Distance is often measured in millimeters. If the scene is modeled in some other scale, Unit Length should be set accordingly. The default value of 0.1 is appropriate for scenes modeled in centimeters and Mean Free Path Distance measured in millimeters.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_6", label: "Glass", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FloatParmTemplate({name: "refractionGain", label: "Refraction Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Refraction gain. This is a multiplier for the refraction.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "reflectionGain", label: "Reflection Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Reflection gain. This is a multiplier for the reflection.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "refractionColor", label: "Refraction Color", num_components: 3, default_value: [1, 1, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setHelp("Refraction color. This sets the color for the refraction.");
			hou_parm_template2.setTags({"script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "glassRoughness", label: "Roughness", num_components: 1, default_value: [0.1], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Roughness for both reflection and refraction. Bigger number is rougher.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "glass_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template2.setTags({"group_type": "collapsible"});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "glassIor", label: "Refractive Index", num_components: 1, default_value: [1.5], min: 1, max: 2, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template3.setHelp("Index of refraction.");
			hou_parm_template3.setTags({"script_ritype": "float"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "thinGlass", label: "Thin", default_value: false});
			hou_parm_template3.setHelp("If on, correctly split energy according to ior between reflection and refraction, but do not bend the ray in refraction (simulating a double pane of glass with a single pane).");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.ToggleParmTemplate({name: "ignoreAccumOpacity", label: "Ignore Accum Opacity", default_value: false});
			hou_parm_template3.setHelp("If on, even if the integrator has Accum Opacity on (where the intention is to generate a partial alpha from refraction for compositing), the alpha will be locally forced to 1.0 after refraction.");
			hou_parm_template3.setTags({"script_ritype": "int"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "glass_interior", label: "Interior", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template3 = new hou.FloatParmTemplate({name: "ssAlbedo", label: "Single Scatter Albedo", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Color of the particles in the volume.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FloatParmTemplate({name: "extinction", label: "Extinction", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template3.setHelp("Extinction coefficient that controls how light is absorbed as it travels through the volume. Higher values will block more light.");
			hou_parm_template3.setTags({"script_ritype": "color"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.FolderParmTemplate({name: "glass_interior_advanced", label: "Advanced", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template3.setTags({"group_type": "collapsible"});
			hou_parm_template4 = new hou.FloatParmTemplate({name: "g", label: "Scattering Directionality", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template4.setHelp("Controls the directionality of the scattering (1: forward, -1: backward, 0:isotropic).");
			hou_parm_template4.setTags({"script_ritype": "float"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "multiScatter", label: "Multiscattering", default_value: false});
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template4 = new hou.ToggleParmTemplate({name: "enableOverlappingVolumes", label: "Overlapping Volumes", default_value: false});
			hou_parm_template4.setHelp("If enable, the interior volume can be overlapped with other volumes to create combined effects.");
			hou_parm_template4.setTags({"script_ritype": "int"});
			hou_parm_template3.addParmTemplate(hou_parm_template4);
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_7", label: "Glow", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FloatParmTemplate({name: "glowGain", label: "Gain", num_components: 1, default_value: [0], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Glow gain. This is a multiplier for the glow.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "glowColor", label: "Color", num_components: 3, default_value: [1, 1, 1], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setHelp("Controls the glow (incandescence) of the material.");
			hou_parm_template2.setTags({"script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "pxrlayer_group_8", label: "Globals", folder_type: hou.folderType.Tabs, default_value: 0, ends_tab_group: false});
			hou_parm_template2 = new hou.FloatParmTemplate({name: "bumpNormal", label: "Bump", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Vector, naming_scheme: hou.parmNamingScheme.XYZW});
			hou_parm_template2.setHelp("Connect a PxrBump node here if you need bump or normal-mapped normals. Only valid when provided as a texture/connection. If the individual lobe's bump normal is set, this global bump be ignored for that lobe.");
			hou_parm_template2.setTags({"script_ritype": "normal"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "shadowColor", label: "Shadow Color", num_components: 3, default_value: [0, 0, 0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.ColorSquare, naming_scheme: hou.parmNamingScheme.RGBA});
			hou_parm_template2.setHelp("Shadow color.");
			hou_parm_template2.setTags({"script_ritype": "color"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "shadowMode", label: "Shadow Mode", menu_items: ["0", "1"], menu_labels: ["Shader and shadow color", "Shadow color only"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("Shadow computation mode. 'Shade and shadow color' mode evaluates the shader for the opacity color for computing the shadow color.");
			hou_parm_template2.setTags({"script_ritype": "int"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "presence", label: "Presence", num_components: 1, default_value: [1], min: 0, max: 1, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Connect a mask function here to apply a cutout pattern to your object. Presence is defined as a binary (0 or 1) function that can take on continuous values to antialias the shape. Useful for modeling leaves and other thin, complex shapes.");
			hou_parm_template2.setTags({"script_ritype": "float"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "presenceCached", label: "Presence Cached", menu_items: ["0", "1"], menu_labels: ["Non cached", "Cached"], default_value: 1, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: true, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setTags({"script_ritype": "int"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "utilityPattern", label: "Utility Pattern", folder_type: hou.folderType.MultiparmBlock, default_value: 1, ends_tab_group: false});
			hou_parm_template.setTags({"multistartoffset": "0", "script_ritype": "int[]"});
			hou_parm_template2 = new hou.IntParmTemplate({name: "utilityPattern_#", label: "Utility Pattern #", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: false, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template2.setHelp("Utility patterns are evaluated but their results are not used by the bxdf. This is where input AOV is connected.");
			hou_parm_template2.setTags({"script_ritype": "int"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			
            this.parmTemplateGroup = hou_parm_template_group;
            this.parmTemplateGroup.linkNode(this);
        }
    }
    hou.registerType('VOP/Other/pxrsurface',_hnt_VOP_pxrsurface)
    return _hnt_VOP_pxrsurface
}
        