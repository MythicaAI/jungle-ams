
export default function (hou) {
    class _hnt_SOP_labs__merge_splines__1_0 extends hou.extend(hou._HoudiniBase).with(hou._SubgraphMixin) {
        static is_root = false;
        static id = 'SOP/Labs/Geometry/Curve/labs::merge_splines::1.0';
        static category = '/SOP/labs';
        static houdiniType = 'labs::merge_splines::1.0';
        static title = 'Labs Merge Splines';
        static icon = '/editor/assets/imgs/nodes/_hnt_SOP_labs__merge_splines__1_0.svg';
        constructor() {
            super();
            this.flags['houdini_type'] = this.__proto__.constructor.houdiniType;
            
            const inputs = ['SOP'];
            const outputs = ['SOP', 'SOP'];

            for(var i=0;i<inputs.length;i++) this.addInput(''+i,inputs[i]);        
            for(var j=0;j<outputs.length;j++) this.addOutput(''+j,outputs[j]);
        }
        parmTemplatesInit() {
            let hou_parm_template_group = new hou.ParmTemplateGroup();
			this.parmTemplateGroup = hou_parm_template_group;
			let hou_parm_template = new hou.FolderParmTemplate({name: "fd_mergesplines", label: "Merge Splines", folder_type: hou.folderType.Simple, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "simple"});
			let hou_parm_template2 = new hou.ToggleParmTemplate({name: "showLabels", label: "Show Help", default_value: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Show or hide the Help labels on each tab, hide to compress the menu for easier reading.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelparm", label: "Label", column_labels: ["Configure how and which subsection of curves provided to the tool are merged."]});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm13"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "fuseDistance", label: "Fuse / Snap Distance", num_components: 1, default_value: [0.001], min: 0, max: 10, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Specify the snapping range of points to help connect disconnected polylines. Best to keep at reasonable levels, as oversnapping can cause undesirable results.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "fuseTargets", label: "Fuse Targets", menu_items: ["0", "1", "2"], menu_labels: ["Any Point", "Only End Points & Existing Intersections", "Only End Points"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("When enabled, only input spline ends with 1 neighbour point and optionally intersections with more than 2 neighbout points will be counted as fuse or merge targets. Spline points with only 2 neighbours will be ignored.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "preFuseFilter_Tgl", label: "Label", default_value: false});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Enable the options for a custom fuse filter, all points are fused by default when disabled.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "preFuseFilter", label: "Fuse Filter", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a groupsToMatchMerge querygroup", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ preFuseFilter_Tgl == 0 }");
			hou_parm_template2.setHelp("If input primitive lines are disconnected, select by point group which splines should be merged by their points. If points between polylines are already connected and \"Only Merge on Fuse Filter Selection\" is enabled, only these points and their connected primitives will be merged, others will be left untouched.");
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_action": "import soputils\nkwargs['geometrytype'] = (hou.geometryType.Points,)\nkwargs['inputindex'] = 0\nsoputils.selectGroupParm(kwargs)", "script_action_help": "Select query geometry from an available viewport.\nShift-click to turn on Select Groups.", "script_action_icon": "BUTTONS_reselect"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "limitMergeOperations", label: "Only Merge on Fuse Filter Selection", default_value: false});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ preFuseFilter_Tgl == 0 }");
			hou_parm_template2.setHelp("When a Fuse Filter point group is provided, only merge polylines connected to the \"fuse filter\" point selection, all other geometry is ignored. This is faster as only the affected geometry is re-calculated, while unaffected geometry is kept untouched. Useful when you need to merge curves into a much larger curve network without unnecessary overhead.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm8"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "onlyMergeIfMatching", label: "Only Merge When Primitive Attributes Match", default_value: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Only merge curves that share one or multiple primitive attributes. Any differences in the specified attributes will prevent 2 polylines from being merged.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelSpacer", label: "Label", column_labels: [""]});
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "attributeToMatch", label: "Attributes to Match", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatch inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ onlyMergeIfMatching == 0 }");
			hou_parm_template2.setHelp("Specify the attribute names to match for merge. (Supported attributes: Int, Float, String, Vector)");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm"});
			hou_parm_template2.setTags({"sidefx::layout_height": "small", "sidefx::look": "blank"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_advancedfusebehaviour", label: "Advanced Fuse Behaviour", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelparm3", label: "Label", column_labels: ["Configures how points are snapped when they are fused together."]});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm12"});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "usetargetgroup", label: "Target Group", default_value: false, default_expression: "off", default_expression_language: hou.scriptLanguage.Hscript});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("When enabled, only snap points to the positions of a target point group.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "targetgroup", label: "Target Group", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a groupsToMatchMerge querygroup", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ usetargetgroup == 0 }");
			hou_parm_template2.setHelp("When enabled, this is the subset of points that will be snapped to points that are allowed to fuse. Otherwise, the fuse points are also the target group.");
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_action": "import soputils\nkwargs['geometrytype'] = (hou.geometryType.Points,)\nkwargs['inputindex'] = -1\nsoputils.selectGroupParm(kwargs)", "script_action_help": "Select target geometry from an available viewport.\nShift-click to turn on Select Groups.", "script_action_icon": "BUTTONS_reselect", "sop_input": "1"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "useradiusattrib", label: "Radius Attribute", default_value: false, default_expression: "off", default_expression_language: hou.scriptLanguage.Hscript});
			hou_parm_template2.hideLabel(true);
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("When enabled, the point attribute with this name is used to specify the radii of the points. Two points will be able to fuse together if the closest distance between their spheres with the corresponding radius is within the Snap Distance.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "radiusattrib", label: "Radius Attribute", num_components: 1, default_value: ["pscale"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a snapPosition radiusattrib", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringReplace});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ useradiusattrib == 0 }");
			hou_parm_template2.setHelp("When enabled, the point attribute with this name is used to specify the radii of the points. Two points will be able to fuse together if the closest distance between their spheres with the corresponding radius is within the Snap Distance.");
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "sop_input": "1"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "onlyFuseIfMatching", label: "Only Fuse when Primitive Attribute Matches", default_value: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Only fuse points from curves that share a primitive attributes. Any differences in the specified attribute will prevent 2 polylines from being fused.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelSpacer2", label: "Label", column_labels: [""]});
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "attributeToMatchFuse", label: "Attribute to Match", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatch inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ onlyFuseIfMatching == 0 }");
			hou_parm_template2.setHelp("Specify an attribute name to match for fusing. (Supported attributes: Int, Float, String, Vector)");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm17"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "positionsnapmethod", label: "Output Positions", menu_items: ["average", "lowest", "highest", "max", "min", "mode", "median", "10", "11"], menu_labels: ["Average Position", "Point Number [First Value]", "Point Number [Last Value]", "Maximum Position", "Minimum Position", "Mode of Position", "Median of Position", "By Attribute [First Value]", "By Attribute [Last Value]"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("The method to use to combine values of Position Attribute when snapping points together. If a \"By Attribute\" method is selected, use the specified point attribute to determine the snap position.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "pointFusePointOrder", label: "Sort By [Point Attrib]", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatchPoint inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringReplace});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ positionsnapmethod != 10 positionsnapmethod != 11 }");
			hou_parm_template2.setHelp("Specify a point attribute that will act as a weight to determine the points position to fuse to. (sorts by numerical or alphabetical order).");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm7"});
			hou_parm_template2.setTags({"sidefx::layout_height": "small", "sidefx::look": "blank"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_primitivebehaviouronmerge", label: "Primitive Behaviour on Merge", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelparm2", label: "Label", column_labels: ["Configures how primitive attributes & vertex order are resolved on curves that are merged together."]});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm10"});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "primAttribMethod", label: "Prim Attrib Promotion", menu_items: ["max", "min", "mean", "mode", "median", "sum", "sumsquare", "rms", "first", "last", "array", "12", "13"], menu_labels: ["Maximum Value", "Minimum Value", "Average", "Mode", "Median", "Sum", "Sum of Squares", "Root Mean Square", "By Prim Number [First Value]", "By Prim Number [Last Value]", "Array of All", "By Attribute [First Value]", "By Attribute [Last Value]"], default_value: 8, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Specify how primitive attributes should be promoted upon merge. If set to \"By Attribute\", a specified attribute can be used to prioritize attribute Promotion.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "primattrib", label: "  Sort By", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatch inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringReplace});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ primAttribMethod != 12 primAttribMethod != 13 }");
			hou_parm_template2.setHelp("If using \"By Attribute\", all primitive attribute conflicts will be resolved by the order of this attribute value (numerical or alphabetical).");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "vertexOrderMethod", label: "Vertex Order [Direction]", menu_items: ["0", "1", "2", "3", "4", "5", "6"], menu_labels: ["Match Prim Attrib Promotion", "By Attribute [First Value]", "By Attribute [Last Value ]", "By Attribute [First Value / Reverse]", "By Attribute [Last Value / Reverse]", "By Prim Number [First Value]", "By Prim Number [Last Value]"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Control how the Vertex Order is promoted for each merged primitive. By default, copies the vertex order set by the \"Prim Attrib Promotion\" method (If set to First/Last \"Prim number\" or \"By Attribute\" mode).  Or it can inherit the Vertex Order from the First/Last Primitive Number between merged primitives.  Alternatively, uses a separate attribute to set the Vertex Order by the First/Last Attribute Value. If values are equal in a merged set of primitives, Defaults to the First Prim Number, unless \"Reverse\" is selected, in which case the Last Prim Number in a matching set is sampled.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.StringParmTemplate({name: "primattribVertexOrder", label: "  Sort By", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatch inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringReplace});
			hou_parm_template2.setConditional(hou.parmCondType.DisableWhen, "{ vertexOrderMethod == 0 } { vertexOrderMethod >= 5 }");
			hou_parm_template2.setHelp("If using \"By Attribute\", all primitive attribute conflicts will be resolved by the order of this attribute value (numerical or alphabetical).");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm2"});
			hou_parm_template2.setTags({"sidefx::layout_height": "medium", "sidefx::look": "blank"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_pointbehaviouronfuse", label: "Point Behaviour on Fuse", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelparm4", label: "Label", column_labels: ["Configures how point attributes and point groups are resolved when they are fused."]});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm3"});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "numpointattribs", label: "Attributes to Snap", folder_type: hou.folderType.MultiparmBlock, default_value: 1, ends_tab_group: false});
			hou_parm_template2.setTags({"autoscope": "0000000000000000"});
			let hou_parm_template3 = new hou.MenuParmTemplate({name: "attribsnapmethod#", label: "Point Attribs Promotion", menu_items: ["max", "min", "mean", "mode", "median", "sum", "sumsquare", "rms", "first", "last", "10", "11"], menu_labels: ["Maximum", "Minimum", "Average", "Mode", "Median", "Sum", "Sum of Squares", "Root Mean Square", "By Point Number [First Value]", "By Point Number [Last Value]", "By Attribute [First Value]", "By Attribute [Last Value]"], default_value: 8, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setJoinWithNext(true);
			hou_parm_template3.setHelp("Specify per point attribute, how they should be resolved upon a merge.");
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.MenuParmTemplate({name: "pointAttribType#", label: "Sort Type", menu_items: ["0", "1"], menu_labels: ["Point Attribute", "Prim Attribute"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ attribsnapmethod# != 10 attribsnapmethod# != 11 }");
			hou_parm_template3.setHelp("When using \"By Attribute\" methods for point attrib promotion, specify if the weight attribute should be obtained from the points being fused, or from their connected primitives.");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.StringParmTemplate({name: "pointAttribPointOrder#", label: "Sort By [Point Attrib]", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatchPoint inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringReplace});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ attribsnapmethod# != 10 attribsnapmethod# != 11 }");
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ pointAttribType# != 0 }");
			hou_parm_template3.setHelp("Specify the attribute name for the point attribute used as a weight value for the \"By Attribute\" Method. (sorts by numerical or alphabetical order).");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.StringParmTemplate({name: "pointAttribPrimOrder#", label: "Sort By [Prim Attrib]", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatch inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringReplace});
			hou_parm_template3.setConditional(hou.parmCondType.DisableWhen, "{ attribsnapmethod# != 10 attribsnapmethod# != 11 }");
			hou_parm_template3.setConditional(hou.parmCondType.HideWhen, "{ pointAttribType# != 1 }");
			hou_parm_template3.setHelp("Specify the attribute name for the prim attribute used as a weight value for the \"By Attribute\" Method. (sorts by numerical or alphabetical order).");
			hou_parm_template3.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template3.setTags({"script_callback_language": "python"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.StringParmTemplate({name: "pointattribnames#", label: "Point Attributes", num_components: 1, default_value: [""], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a attribsToMatchPoint inname", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template3.setHelp("Specify which point attributes to resolve.");
			hou_parm_template3.setTags({"sop_input": "1"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm11"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FolderParmTemplate({name: "numgroups", label: "Groups to Snap", folder_type: hou.folderType.MultiparmBlock, default_value: 1, ends_tab_group: false});
			hou_parm_template2.setTags({"autoscope": "0000000000000000"});
			hou_parm_template3 = new hou.MenuParmTemplate({name: "grouppropagation#", label: "Group Propagation", menu_items: ["leastpointnumber", "greatestpointnumber", "union", "intersect", "mode"], menu_labels: ["Least Point Number", "Greatest Point Number", "Union", "Intersect", "Most Common"], default_value: 2, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template3.setHelp("Specify per point group, how they should be resolved upon a merge.");
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template3 = new hou.StringParmTemplate({name: "pointgroupnames#", label: "Point Group Names", num_components: 1, default_value: ["*"], naming_scheme: hou.parmNamingScheme.Base1, string_type: hou.stringParmType.Regular, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "opmenu -l -a groupsToMatchMerge querygroup", item_generator_script_language: hou.scriptLanguage.Hscript, menu_type: hou.menuType.StringToggle});
			hou_parm_template3.setHelp("Specify which point groups to resolve.");
			hou_parm_template3.setTags({"sop_input": "1"});
			hou_parm_template2.addParmTemplate(hou_parm_template3);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm4"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "vertexAttribMethod", label: "Vertex Attrib Promotion", menu_items: ["max", "min", "mean", "mode", "median", "sum", "sumsquare", "rms", "first", "last", "array"], menu_labels: ["Maximum", "Minimum", "Average", "Mode", "Median", "Sum", "Sum of Squares", "Root Mean Square", "By Point Number [First Value]", "By Point Number [Last Value]", "Array of All"], default_value: 8, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("Specify how vertex attributes should be promoted when two curves are merged together.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm16"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "sortByVertexOrder", label: "Sort By Vertex Order", default_value: true});
			hou_parm_template2.setHelp("When enabled, sorts the output geometry point numbers by their vertex order.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm6"});
			hou_parm_template2.setTags({"sidefx::layout_height": "small", "sidefx::look": "blank"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_visualfeedback", label: "Visual Feedback", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelparm6", label: "Label", column_labels: ["Configures how the guide output is displayed."]});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm15"});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "guideScale", label: "Guide Scale", num_components: 1, default_value: [5], min: 0, max: 5, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setHelp("Set the scale of wireframe guide objects visible when the node is selected and that are provided from output 2.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "showSourceVertexOrder", label: "Show Source Vertex Order", default_value: true});
			hou_parm_template2.setHelp("Displays the Original Polyline Vertex Order as smaller Direction Guides.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm5"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "colorSegments", label: "Color Segments", default_value: false});
			hou_parm_template2.setJoinWithNext(true);
			hou_parm_template2.setHelp("Enable primitive color visualization on the output primitives per primitive.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "colorSeed", label: "Seed", num_components: 1, default_value: [0], min: 0, max: 10, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ colorSegments == 0 }");
			hou_parm_template2.setTags({"autoscope": "0000000000000000"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm18"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "outGuideColorClass", label: "Guide Color", menu_items: ["0", "1", "2"], menu_labels: ["Primitive Color", "Point Color", "Vertex Color"], default_value: 2, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("Specify what color class the Guide Visual Output should be. Useful for color attribute compatibility when merged with other geometry.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.ToggleParmTemplate({name: "outGuidePacked", label: "Pack Guide Output", default_value: true});
			hou_parm_template2.setHelp("Output the Guide Visual Geometry as Packed Geometry instead.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.SeparatorParmTemplate({name: "sepparm9"});
			hou_parm_template_group.append(hou_parm_template);
			hou_parm_template = new hou.FolderParmTemplate({name: "fd_cleancurvesuponinput", label: "Clean Nurbs and Bezier Curves upon Input", folder_type: hou.folderType.Collapsible, default_value: 0, ends_tab_group: false});
			hou_parm_template.setTags({"group_type": "collapsible"});
			hou_parm_template2 = new hou.LabelParmTemplate({name: "labelparm5", label: "Label", column_labels: ["This utility only outputs polylines, configure here how to process NURBS and Bezier Curves."]});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template2.hideLabel(true);
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.SeparatorParmTemplate({name: "sepparm14"});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ showLabels == 0 }");
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.MenuParmTemplate({name: "conversionMethod", label: "Clean Method", menu_items: ["0", "1", "2"], menu_labels: ["Skip non-Polyline Curves", "Convert using Level of Detail", "Convert using Divisions per Span"], default_value: 0, icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false, is_button_strip: false, strip_uses_icons: false});
			hou_parm_template2.setHelp("Configures how to clean non-supported geometry types, such as NURBS and Bezier Curves.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.FloatParmTemplate({name: "lodu", label: "Level of Detail", num_components: 1, default_value: [0.5], min: 0.001, max: 5, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ conversionMethod != 1 }");
			hou_parm_template2.setHelp("Point density along the curves U direction.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template2 = new hou.IntParmTemplate({name: "divu", label: "Divisions Per Span", num_components: 1, default_value: [2], min: 0, max: 5, min_is_strict: true, max_is_strict: false, look: hou.parmLook.Regular, naming_scheme: hou.parmNamingScheme.Base1, menu_items: [], menu_labels: [], icon_names: [], item_generator_script: "", item_generator_script_language: hou.scriptLanguage.Python, menu_type: hou.menuType.Normal, menu_use_token: false});
			hou_parm_template2.setConditional(hou.parmCondType.HideWhen, "{ conversionMethod != 2 }");
			hou_parm_template2.setHelp("Point count along the curves U direction.");
			hou_parm_template2.setScriptCallbackLanguage(hou.scriptLanguage.Python);
			hou_parm_template2.setTags({"autoscope": "0000000000000000", "script_callback_language": "python"});
			hou_parm_template.addParmTemplate(hou_parm_template2);
			hou_parm_template_group.append(hou_parm_template);
			
            this.parmTemplateGroup = hou_parm_template_group;
            this.parmTemplateGroup.linkNode(this);
        }
    }
    hou.registerType('SOP/Labs/Geometry/Curve/labs::merge_splines::1.0',_hnt_SOP_labs__merge_splines__1_0)
    return _hnt_SOP_labs__merge_splines__1_0
}
        